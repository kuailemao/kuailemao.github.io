<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring5-新功能</title>
      <link href="/kuailemao/12d19e4c.html"/>
      <url>/kuailemao/12d19e4c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Spring5-框架新功能"><a href="#Spring5-框架新功能" class="headerlink" title="Spring5 框架新功能"></a>Spring5 框架新功能</h3><p><strong>1、整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方 法在代码库中删除</strong></p><h4 id="2、Spring-5-0-框架自带了通用的日志封装"><a href="#2、Spring-5-0-框架自带了通用的日志封装" class="headerlink" title="2、Spring 5.0 框架自带了通用的日志封装"></a>2、Spring 5.0 框架自带了通用的日志封装</h4><p>（1）Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2</p><p>（2）Spring5 框架整合 Log4j2</p><p><strong>第一步</strong> 引入 jar 包</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623095537835.png" alt="image-20220623095537835"></p><p><strong>第二步</strong> 创建 log4j2.xml 配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、Spring5-框架核心容器支持-Nullable-注解"><a href="#3、Spring5-框架核心容器支持-Nullable-注解" class="headerlink" title="3、Spring5 框架核心容器支持@Nullable 注解"></a>3、Spring5 框架核心容器支持@Nullable 注解</h4><p>（1）@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以 为空，参数值可以为空</p><p>（2）注解用在方法上面，方法返回值可以为空</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623095812725.png" alt="image-20220623095812725"> </p><p>（3）注解使用在方法参数里面，方法参数可以为空</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623095852356.png" alt="image-20220623095852356"></p><p>（4）注解使用在属性上面，属性值可以为空</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623095918791.png" alt="image-20220623095918791"> </p><h4 id="4、Spring5-核心容器支持函数式风格-GenericApplicationContext"><a href="#4、Spring5-核心容器支持函数式风格-GenericApplicationContext" class="headerlink" title="4、Spring5 核心容器支持函数式风格 GenericApplicationContext"></a>4、Spring5 核心容器支持函数式风格 GenericApplicationContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式风格创建对象，交给 spring 进行管理</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenericApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//1 创建 GenericApplicationContext 对象</span></span><br><span class="line"> <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"> <span class="comment">//2 调用 context 的方法对象注册</span></span><br><span class="line"> context.refresh();</span><br><span class="line"> context.registerBean(<span class="string">&quot;user1&quot;</span>,User.class,() -&gt; <span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"> <span class="comment">//3 获取在 spring 注册的对象</span></span><br><span class="line"> <span class="comment">// User user = (User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;);</span></span><br><span class="line"> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line"> System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Spring5-支持整合-JUnit5"><a href="#5、Spring5-支持整合-JUnit5" class="headerlink" title="5、Spring5 支持整合 JUnit5"></a>5、Spring5 支持整合 JUnit5</h4><p>（1）整合 JUnit4 </p><p><strong>第一步</strong> 引入 Spring 相关针对测试依赖</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623100143688.png" alt="image-20220623100143688"> </p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623100216918.png" alt="image-20220623100216918"> </p><p><strong>第二步</strong> 创建测试类，使用注解方式完成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class) //单元测试框架</span><br><span class="line">@ContextConfiguration(&quot;classpath:bean1.xml&quot;) //加载配置文件</span><br><span class="line">public class JTest4 &#123;</span><br><span class="line"> @Autowired</span><br><span class="line"> private UserService userService;</span><br><span class="line"> @Test</span><br><span class="line"> public void test1() &#123;</span><br><span class="line"> userService.accountMoney();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）Spring5 整合 JUnit5</p><p><strong>第一步</strong> 引入 JUnit5 的 jar 包</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623100423603.png" alt="image-20220623100423603"> </p><p><strong>第二步</strong> 创建测试类，使用注解完成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ExtendWith(SpringExtension.class)</span><br><span class="line">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span><br><span class="line">public class JTest5 &#123;</span><br><span class="line"> @Autowired</span><br><span class="line"> private UserService userService;</span><br><span class="line"> @Test</span><br><span class="line"> public void test1() &#123;</span><br><span class="line"> userService.accountMoney();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用一个复合注解替代上面两个注解完成整合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)</span><br><span class="line">public class JTest5 &#123;</span><br><span class="line"> @Autowired</span><br><span class="line"> private UserService userService;</span><br><span class="line"> @Test</span><br><span class="line"> public void test1() &#123;</span><br><span class="line"> userService.accountMoney();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring5-框架新功能（Webflux）"><a href="#Spring5-框架新功能（Webflux）" class="headerlink" title="Spring5 框架新功能（Webflux）"></a>Spring5 框架新功能（Webflux）</h4><p>。。。。待完善</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5-事务</title>
      <link href="/kuailemao/65c808d7.html"/>
      <url>/kuailemao/65c808d7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><h4 id="事务操作（事务概念）"><a href="#事务操作（事务概念）" class="headerlink" title="事务操作（事务概念）"></a>事务操作（事务概念）</h4><p><strong>1、什么事务</strong></p><p>（1）事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操 作都失败</p><p>（2）典型场景：银行转账</p><ul><li>lucy 转账 100 元 给 mary </li><li>lucy 少 100，mary 多 100</li></ul><p><strong>2、事务四个特性（ACID）</strong></p><p>（1）原子性 </p><p>（2）一致性 </p><p>（3）隔离性 </p><p>（4）持久性</p><h4 id="事务操作（搭建事务操作环境）"><a href="#事务操作（搭建事务操作环境）" class="headerlink" title="事务操作（搭建事务操作环境）"></a>事务操作（搭建事务操作环境）</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623085209008.png" alt="image-20220623085209008"> </p><p><strong>1、创建数据库表，添加记录</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623085321775.png" alt="image-20220623085321775"></p><p><strong>2、创建 service，搭建 dao，完成对象创建和注入关系</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="comment">//注入 dao</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、在 dao 创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法）</strong></p><ul><li><p>dao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"> <span class="comment">//lucy 转账 100 给 mary</span></span><br><span class="line"> <span class="comment">//少钱</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduceMoney</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_account set money=money-? where username=?&quot;</span>;</span><br><span class="line"> jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//多钱</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMoney</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_account set money=money+? where username=?&quot;</span>;</span><br><span class="line"> jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;mary&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>service</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="comment">//注入 dao</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//转账的方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accountMoney</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//lucy 少 100</span></span><br><span class="line"> userDao.reduceMoney();</span><br><span class="line"> <span class="comment">//mary 多 100</span></span><br><span class="line"> userDao.addMoney();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常，有问题</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623085801370.png" alt="image-20220623085801370"> </p><p>（1）上面问题如何解决呢？</p><ul><li>使用事务进行解决</li></ul><p>（2）事务操作过程</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623090118998.png" alt="image-20220623090118998"> </p><h4 id="事务操作（Spring-事务管理介绍）"><a href="#事务操作（Spring-事务管理介绍）" class="headerlink" title="事务操作（Spring 事务管理介绍）"></a>事务操作（Spring 事务管理介绍）</h4><p><strong>1、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）</strong></p><p><strong>2、在 Spring 进行事务管理操作</strong></p><p><strong>（1）有两种方式：</strong> <strong>编程式事务管理</strong>和<strong>声明式事务管理</strong>（使用）</p><p><strong>3、声明式事务管理</strong></p><p><strong>（1）</strong>基于注解方式（使用） </p><p>（2）基于 xml 配置文件方式</p><p><strong>4、在 Spring 进行声明式事务管理，底层使用 AOP 原理</strong></p><p><strong>5、Spring 事务管理 API</strong></p><p>（1）提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623090718455.png" alt="image-20220623090718455"></p><h4 id="事务操作（注解声明式事务管理）"><a href="#事务操作（注解声明式事务管理）" class="headerlink" title="事务操作（注解声明式事务管理）"></a>事务操作（注解声明式事务管理）</h4><p><strong>1、在 spring 配置文件配置事务管理器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、在 spring 配置文件，开启事务注解</strong></p><p>（1）在 spring 配置文件引入名称空间 tx</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623090915302.png" alt="image-20220623090915302"></p><p>（2）开启事务注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transactionmanager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3、在 service 类上面（或者 service 类里面方法上面）添加事务注解</strong></p><p>（1）@Transactional，这个注解添加到类上面，也可以添加方法上面 </p><p>（2）如果把这个注解添加类上面，这个类里面所有的方法都添加事务 </p><p>（3）如果把这个注解添加方法上面，为这个方法添加事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class UserService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务操作（声明式事务管理参数配置）"><a href="#事务操作（声明式事务管理参数配置）" class="headerlink" title="事务操作（声明式事务管理参数配置）"></a>事务操作（声明式事务管理参数配置）</h4><p><strong>1、在 service 类上面添加注解 @Transactional，在这个注解里面可以配置事务相关参数</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623091315211.png" alt="image-20220623091315211"></p><p><strong>2、propagation：事务传播行为</strong></p><p><strong>（1）多事务方法直接进行调用，这个过程中事务 是如何进行管理的</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623091615508.png" alt="image-20220623091615508"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623091934427.png" alt="image-20220623091934427"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA.bmp" alt="事务传播行为"> </p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623092027179.png" alt="image-20220623092027179"> </p><p><strong>3、ioslation：事务隔离级别</strong></p><p>（1）事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题 </p><p>（2）有三个读问题：脏读、不可重复读、虚（幻）读 </p><p>（3）脏读：一个未提交事务读取到另一个未提交事务的数据</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623092134336.png" alt="image-20220623092134336">  </p><p>（4）不可重复读：一个未提交事务读取到另一提交事务修改数据</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623092351896.png" alt="image-20220623092351896"></p><p>（5）虚读：一个未提交事务读取到另一提交事务添加数据</p><p>（6）解决：通过设置事务隔离级别，解决读问题</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.bmp" alt="事务隔离级别"> </p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220623094852429.png" alt="image-20220623094852429"></p><p><strong>4、timeout：超时时间</strong></p><p>（1）事务需要在一定时间内进行提交，如果不提交进行回滚 </p><p>（2）默认值是 -1 ，设置时间以秒单位进行计算</p><p><strong>5、readOnly：是否只读</strong></p><p>（1）读：查询操作，写：添加修改删除操作 </p><p>（2）readOnly 默认值 false，表示可以查询，可以添加修改删除操作 </p><p>（3）设置 readOnly 值是 true，设置成 true 之后，只能查询</p><p><strong>6、rollbackFor：回滚</strong></p><p>（1）设置出现哪些异常进行事务回滚</p><p><strong>7、noRollbackFor：不回滚</strong></p><p>（1）设置出现哪些异常不进行事务回滚</p><h4 id="事务操作（XML-声明式事务管理）"><a href="#事务操作（XML-声明式事务管理）" class="headerlink" title="事务操作（XML 声明式事务管理）"></a>事务操作（XML 声明式事务管理）</h4><p><strong>1、在 spring 配置文件中进行配置</strong></p><p>第一步 配置事务管理器 </p><p>第二步 配置通知 </p><p>第三步 配置切入点和切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2 配置通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置事务参数--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--指定哪种规则的方法上面添加事务--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;accountMoney&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3 配置切入点和切面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* </span></span></span><br><span class="line"><span class="string"><span class="tag">com.atguigu.spring5.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="事务操作（完全注解声明式事务管理）"><a href="#事务操作（完全注解声明式事务管理）" class="headerlink" title="事务操作（完全注解声明式事务管理）"></a>事务操作（完全注解声明式事务管理）</h4><p><strong>1、创建配置类，使用配置类替代 xml 配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Configuration  // 配置类</span><br><span class="line">@ComponentScan(basePackages = &quot;com.kuailemao.spring5&quot;)  // 组件扫描</span><br><span class="line">@EnableTransactionManagement    // 开启事务</span><br><span class="line">public class TxConfig &#123;</span><br><span class="line">    // 创建数据库连接池</span><br><span class="line">    @Bean</span><br><span class="line">    public DruidDataSource getDruidDataSource()&#123;</span><br><span class="line">        DruidDataSource druidDataSource = new DruidDataSource();</span><br><span class="line">        druidDataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        druidDataSource.setUrl(&quot;jdbc:mysql://localhost/user_db?serverTimezone=GMT%2B8&quot;);</span><br><span class="line">        druidDataSource.setUsername(&quot;root&quot;);</span><br><span class="line">        druidDataSource.setPassword(&quot;123456&quot;);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建 JdbcTemplate 对象</span><br><span class="line">    @Bean</span><br><span class="line">    public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123;</span><br><span class="line">        // 到 ioc 容器中根据类型找到 dataSource</span><br><span class="line">        JdbcTemplate jdbcTemplate = new JdbcTemplate();</span><br><span class="line">        // 注入 DataSource</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        return jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建事务管理器对象</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123;</span><br><span class="line">        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        return transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-JdbcTemplate</title>
      <link href="/kuailemao/8950f30e.html"/>
      <url>/kuailemao/8950f30e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h3><h4 id="JdbcTemplate-概念和准备"><a href="#JdbcTemplate-概念和准备" class="headerlink" title="JdbcTemplate(概念和准备)"></a>JdbcTemplate(概念和准备)</h4><p><strong>1、什么是 JdbcTemplate</strong></p><p>（1）Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p><p><strong>2、准备工作</strong></p><p>（1）引入相关 jar 包</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220621000656347.png" alt="image-20220621000656347"> </p><p>（2）在 spring 配置文件配置数据库连接池</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///user_db&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）配置 JdbcTemplate 对象，注入 DataSource</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JdbcTemplate 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--注入 dataSource--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象</p><ul><li>配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要先注入 context 名称空间</p></blockquote><ul><li>Service 方法</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line"> //注入 dao</span><br><span class="line"> @Autowired</span><br><span class="line"> private BookDao bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dao 方法</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"> //注入 JdbcTemplate</span><br><span class="line"> @Autowired</span><br><span class="line"> private JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JdbcTemplate-操作数据库（添加）"><a href="#JdbcTemplate-操作数据库（添加）" class="headerlink" title="JdbcTemplate 操作数据库（添加）"></a>JdbcTemplate 操作数据库（添加）</h4><p><strong>1、对应数据库创建实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUid</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;uid=&#x27;&quot;</span> + uid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、编写 service 和 dao</strong></p><p>（1）在 dao 进行数据库添加操作</p><p>（2）调用 JdbcTemplate 对象里面 update 方法实现添加操作</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220621001639289.png" alt="image-20220621001639289"> </p><p><strong>有两个参数：</strong></p><ul><li><p>第一个参数：sql 语句</p></li><li><p>第二个参数：可变参数，设置 sql 语句值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span>&#123;</span><br><span class="line">    <span class="comment">// 注入JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建 sql 语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into student(uid,name,age)  values(?,?,?);&quot;</span>;</span><br><span class="line">        <span class="comment">// 2.调用方法实现</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, user.getUid(), user.getName(), user.getAge());</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3、测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"> <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bookService&quot;</span>, </span><br><span class="line">BookService.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUid(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">15</span>);</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    bookService.addUser(user);</span><br></pre></td></tr></table></figure><h4 id="JdbcTemplate-操作数据库（修改和删除）"><a href="#JdbcTemplate-操作数据库（修改和删除）" class="headerlink" title="JdbcTemplate 操作数据库（修改和删除）"></a>JdbcTemplate 操作数据库（修改和删除）</h4><p><strong>1、修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update student set name = ? where uid = ?;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, user.getName(), user.getUid());</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from student where uid = ?&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, id);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JdbcTemplate-操作数据库（查询返回某个值）"><a href="#JdbcTemplate-操作数据库（查询返回某个值）" class="headerlink" title="JdbcTemplate 操作数据库（查询返回某个值）"></a>JdbcTemplate 操作数据库（查询返回某个值）</h4><p><strong>1、查询表里面有多少条记录，返回是某个值</strong></p><p><strong>2、使用 JdbcTemplate 实现查询返回某个值代码</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220621002321028.png" alt="image-20220621002321028"> </p><p><strong>有两个参数：</strong></p><ul><li>第一个参数：sql 语句</li><li>第二个参数：返回类型 Class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询返回记录条数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">UserCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select COUNt(*) from student;&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JdbcTemplate-操作数据库（查询返回对象）"><a href="#JdbcTemplate-操作数据库（查询返回对象）" class="headerlink" title="JdbcTemplate 操作数据库（查询返回对象）"></a>JdbcTemplate 操作数据库（查询返回对象）</h4><p><strong>1、场景：查询图书详情</strong></p><p><strong>2、JdbcTemplate 实现查询返回对象</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220621002636704.png" alt="image-20220621002636704"> </p><p><strong>有三个参数 ：</strong></p><ul><li>第一个参数：sql 语句</li><li>第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装</li><li>第三个参数：sql 语句值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询返回对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserInfo</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from student where uid = ?;&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class), id);</span><br><span class="line">     <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查询出来的对象会通过实体类的set方法自动把数据封装进去，很方便</p></blockquote><h4 id="JdbcTemplate-操作数据库（查询返回集合）"><a href="#JdbcTemplate-操作数据库（查询返回集合）" class="headerlink" title="JdbcTemplate 操作数据库（查询返回集合）"></a>JdbcTemplate 操作数据库（查询返回集合）</h4><p><strong>1、场景：查询图书列表分页…</strong></p><p><strong>2、调用 JdbcTemplate 方法实现查询返回集合</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220621003544459.png" alt="image-20220621003544459"> </p><p><strong>有三个参数 ：</strong></p><ul><li>第一个参数：sql 语句</li><li>第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装</li><li>第三个参数：sql 语句值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询返回集合</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from student;&quot;</span>;</span><br><span class="line">    List&lt;User&gt; bookList = jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class));</span><br><span class="line">    <span class="keyword">return</span> bookList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JdbcTemplate-操作数据库（批量操作）"><a href="#JdbcTemplate-操作数据库（批量操作）" class="headerlink" title="JdbcTemplate 操作数据库（批量操作）"></a>JdbcTemplate 操作数据库（批量操作）</h4><h5 id="1、批量操作：操作表里面多条记录"><a href="#1、批量操作：操作表里面多条记录" class="headerlink" title="1、批量操作：操作表里面多条记录"></a>1、批量操作：操作表里面多条记录</h5><h5 id="2、JdbcTemplate-实现批量添加操作"><a href="#2、JdbcTemplate-实现批量添加操作" class="headerlink" title="2、JdbcTemplate 实现批量添加操作"></a>2、JdbcTemplate 实现批量添加操作</h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220621003703687.png" alt="image-20220621003703687"> </p><p><strong>有两个参数：</strong></p><ul><li>第一个参数：sql 语句</li><li>第二个参数：List 集合，添加多条记录数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量添加</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchAddBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line"> <span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line"> System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类里面使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量添加测试</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;5&quot;</span>,<span class="string">&quot;MySQL&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用批量添加</span></span><br><span class="line">bookService.batchAddBook(batchArgs);</span><br></pre></td></tr></table></figure><blockquote><p>把多条数据放进过个数组里面，在把数组放进集合里面，最后把集合当参数</p></blockquote><h5 id="3、JdbcTemplate-实现批量修改操作"><a href="#3、JdbcTemplate-实现批量修改操作" class="headerlink" title="3、JdbcTemplate 实现批量修改操作"></a>3、JdbcTemplate 实现批量修改操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量修改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdateBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line"> <span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line"> System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类里面使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量修改测试</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;java0909&quot;</span>,<span class="string">&quot;a3&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;c++1010&quot;</span>,<span class="string">&quot;b4&quot;</span>,<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;MySQL1111&quot;</span>,<span class="string">&quot;c5&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用方法实现批量修改</span></span><br><span class="line">bookService.batchUpdate(batchArgs);</span><br></pre></td></tr></table></figure><blockquote><p>sql 语句不同，其他跟 <strong>批量添加操作</strong> 相同</p></blockquote><p>##3## 4、JdbcTemplate 实现批量删除操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchDeleteBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line"> <span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line"> System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类里面使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line"><span class="comment">//调用方法实现批量删除</span></span><br><span class="line">bookService.batchDelete(batchArgs);</span><br></pre></td></tr></table></figure><blockquote><p>sql 语句不同，其他跟 <strong>批量添加操作</strong> 相同</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-AOP</title>
      <link href="/kuailemao/97375e6e.html"/>
      <url>/kuailemao/97375e6e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h4 id="在配置文件配置创建的对象"><a href="#在配置文件配置创建的对象" class="headerlink" title="在配置文件配置创建的对象"></a>在配置文件配置创建的对象</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuailemao.spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>id：名称（别名）</li><li>class：类的全路径（src下）</li></ul><h4 id="在类里面使用"><a href="#在类里面使用" class="headerlink" title="在类里面使用"></a>在类里面使用</h4><p>1、加载 spring 配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>); </span><br></pre></td></tr></table></figure><ul><li>bean1.xml 是配置文件</li></ul><p>2、获取配置创建的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br></pre></td></tr></table></figure><ul><li>“user” 是 配置文件里面的 id</li></ul><blockquote><p>这样就得到了一个 User 对象、</p></blockquote><h3 id="IOC（概念和原理）"><a href="#IOC（概念和原理）" class="headerlink" title="IOC（概念和原理）"></a>IOC（概念和原理）</h3><h4 id="什么是-IOC"><a href="#什么是-IOC" class="headerlink" title="什么是 IOC"></a>什么是 IOC</h4><p>1、控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理<br>2、使用 IOC 目的：为了耦合度降低</p><h4 id="IOC-底层原理"><a href="#IOC-底层原理" class="headerlink" title="IOC 底层原理"></a>IOC 底层原理</h4><blockquote><p>xml 解析+工厂模式+反射 &#x3D; IOC </p></blockquote><h4 id="IOC-过程"><a href="#IOC-过程" class="headerlink" title="IOC 过程"></a>IOC 过程</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220610094515981.png" alt="image-20220610094515981"></p><h3 id="IOC（BeanFactory-接口）"><a href="#IOC（BeanFactory-接口）" class="headerlink" title="IOC（BeanFactory 接口）"></a>IOC（BeanFactory 接口）</h3><p>1、IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂</p><p>2、Spring 提供 IOC 容器实现两种方式：（两个接口）</p><p>（1）BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用</p><ul><li>加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</li></ul><p>（2）ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用</p><ul><li>加载配置文件时候就会把在配置文件对象进行创建</li></ul><p>3、ApplicationContext 接口有实现类</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220610095254011.png" alt="image-20220610095254011"></p><h3 id="IOC-操作-Bean-管理（概念）"><a href="#IOC-操作-Bean-管理（概念）" class="headerlink" title="IOC 操作 Bean 管理（概念）"></a>IOC 操作 Bean 管理（概念）</h3><h4 id="1、什么是-Bean-管理"><a href="#1、什么是-Bean-管理" class="headerlink" title="1、什么是 Bean 管理"></a>1、什么是 Bean 管理</h4><blockquote><p>Bean 管理指的是两个操作 </p></blockquote><ul><li><p>Spring 创建对象 </p></li><li><p>Spirng 注入属性</p></li></ul><h4 id="2、Bean-管理操作有两种方式"><a href="#2、Bean-管理操作有两种方式" class="headerlink" title="2、Bean 管理操作有两种方式"></a>2、Bean 管理操作有两种方式</h4><ul><li>基于 xml 配置文件方式实现</li><li>基于注解方式实现</li></ul><h3 id="IOC-操作-Bean-管理（基于-xml-方式）"><a href="#IOC-操作-Bean-管理（基于-xml-方式）" class="headerlink" title="IOC 操作 Bean 管理（基于 xml 方式）"></a>IOC 操作 Bean 管理（基于 xml 方式）</h3><h4 id="1、基于-xml-方式创建对象"><a href="#1、基于-xml-方式创建对象" class="headerlink" title="1、基于 xml 方式创建对象"></a>1、基于 xml 方式创建对象</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuailemao.spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（1）在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建</p><p>（2）在 bean 标签有很多属性，介绍常用的属性</p><ul><li>id 属性：唯一标识</li><li>class 属性：类全路径（包类路径）</li></ul><p>（3）创建对象时候，默认也是执行无参数构造方法完成对象创建</p><h4 id="2、基于-xml-方式注入属性"><a href="#2、基于-xml-方式注入属性" class="headerlink" title="2、基于 xml 方式注入属性"></a>2、基于 xml 方式注入属性</h4><blockquote><p>DI：依赖注入，就是注入属性</p></blockquote><p><strong>两种注入属性方式：</strong></p><blockquote><p>1、使用 set 方法进行注入</p><p>2、使用有参数构造进行注入</p></blockquote><h4 id="使用-set-方法进行注入"><a href="#使用-set-方法进行注入" class="headerlink" title="使用 set 方法进行注入"></a>使用 set 方法进行注入</h4><blockquote><p>创建类，定义属性和对应的 set 方法</p></blockquote><p><strong>配置文件配置对象创建，配置属性注入：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过 set 方法注入属性--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuailemao.spring5.User&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>property标签：</strong></p><blockquote><p>name：属性的名称</p><p>value：注入的值</p></blockquote><h4 id="使用有参数构造进行注入"><a href="#使用有参数构造进行注入" class="headerlink" title="使用有参数构造进行注入"></a>使用有参数构造进行注入</h4><blockquote><p>创建类，定义属性，创建属性对应有参数构造方法</p></blockquote><p><strong>在 spring 配置文件中进行配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过 有参构造方法 注入属性--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuailemao.spring5.User&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>写完   &lt;bean id&#x3D;”user02” class&#x3D;”com.kuailemao.spring5.User”&gt; &lt;bean&gt; 之后报错是因为默认是无参构造方法创建对象，使用 &lt;constructor-arg&gt; &lt;&#x2F;constructor-arg&gt; 写上对应的有参构造方法的参数后就可以了</p></blockquote><p><strong>注意：</strong>定义<strong>有参构造</strong>后默认的<strong>无参构造</strong>则会消失，要使用无参创建对象则需要<strong>手动写出无参构造方法</strong></p><h4 id="p-名称空间注入（了解）"><a href="#p-名称空间注入（了解）" class="headerlink" title="p 名称空间注入（了解）"></a>p 名称空间注入（了解）</h4><blockquote><p>使用 p 名称空间注入，可以简化基于 xml 配置方式</p></blockquote><blockquote><p>1、添加 p 名称空间在配置文件中 </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220610104138343.png" alt="image-20220610104138343"></p><p><strong>使用：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过 p名称注入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user03&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuailemao.spring5.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;王五&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>p:属性</p></blockquote><h3 id="IOC-操作-Bean-管理（xml-注入其他类型属性）"><a href="#IOC-操作-Bean-管理（xml-注入其他类型属性）" class="headerlink" title="IOC 操作 Bean 管理（xml 注入其他类型属性）"></a>IOC 操作 Bean 管理（xml 注入其他类型属性）</h3><h5 id="1、字面量"><a href="#1、字面量" class="headerlink" title="1、字面量"></a>1、字面量</h5><p><strong>（1）null 值：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--null 值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（2）属性值包含特殊符号：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--属性值包含特殊符号</span><br><span class="line"> 1 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span><br><span class="line"> 2 把带特殊符号内容写到 CDATA</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!-- 第一种 --&gt;</span><br><span class="line">&lt;property name=&quot;address&quot;&gt;</span><br><span class="line">&lt;value&gt;&amp;lt;南京&amp;gt;&lt;/value&gt; &lt;!-- &lt;南京&gt; --&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 第二种 --&gt;</span><br><span class="line">&lt;property name=&quot;address&quot;&gt;</span><br><span class="line"> &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt; &lt;!-- &lt;南京&gt; --&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><h5 id="2、注入属性-外部-bean"><a href="#2、注入属性-外部-bean" class="headerlink" title="2、注入属性-外部 bean"></a>2、注入属性-外部 bean</h5><blockquote><p>（1）创建两个类 service 类和 dao 类<br>（2）在 service 调用 dao 里面的方法</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line"> //创建 UserDao 类型属性，生成 set 方法</span><br><span class="line"> private UserDao userDao;</span><br><span class="line">     public void setUserDao(UserDao userDao) &#123;</span><br><span class="line"> this.userDao = userDao;</span><br><span class="line"> &#125;</span><br><span class="line"> public void add() &#123;</span><br><span class="line"> System.out.println(&quot;service add...............&quot;);</span><br><span class="line"> userDao.update();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（3）在 spring 配置文件中进行配置</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 service 和 dao 对象创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.service.UserService&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--注入 userDao 对象</span></span><br><span class="line"><span class="comment"> name 属性：类里面属性名称</span></span><br><span class="line"><span class="comment"> ref 属性：创建 userDao 对象 bean 标签 id 值</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>ref&#x3D;” “ 是跟最底下 bean 的id 一致的</p></blockquote><h5 id="3、注入属性-内部-bean"><a href="#3、注入属性-内部-bean" class="headerlink" title="3、注入属性-内部 bean"></a>3、注入属性-内部 bean</h5><blockquote><p>（1）一对多关系：部门和员工，一个部门有多个员工，一个员工属于一个部门，部门是一，员工是多<br>（2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部门类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> String dname;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDname</span><span class="params">(String dname)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.dname = dname;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> String ename;</span><br><span class="line"> <span class="keyword">private</span> String gender;</span><br><span class="line"> <span class="comment">//员工属于某一个部门，使用对象形式表示</span></span><br><span class="line"> <span class="keyword">private</span> Dept dept;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDept</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.dept = dept;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEname</span><span class="params">(String ename)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.ename = ename;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.gender = gender;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（3）在 spring 配置文件中进行配置</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--内部 bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--设置对象类型属性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;安保部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4、注入属性-级联赋值"><a href="#4、注入属性-级联赋值" class="headerlink" title="4、注入属性-级联赋值"></a>4、注入属性-级联赋值</h5><p><strong>（1）第一种写法 ：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（2）第二种写法：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220613010857918.png" alt="image-20220613010857918"> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;技术部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>‘<strong>dept.dname</strong>‘ 是通过<strong>getDept()<strong>获取到</strong>dept</strong>对象然后点它的<strong>dname</strong>属性</p></blockquote><blockquote><p>上面的 <strong>dept</strong> 对象的创建是：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="IOC-操作-Bean-管理（xml-注入集合属性）"><a href="#IOC-操作-Bean-管理（xml-注入集合属性）" class="headerlink" title="IOC 操作 Bean 管理（xml 注入集合属性）"></a>IOC 操作 Bean 管理（xml 注入集合属性）</h3><blockquote><p><strong>1、注入数组类型属性</strong> </p><p><strong>2、注入 List 集合类型属性</strong> </p><p><strong>3、注入 Map 集合类型属性</strong></p><p><strong>4、注入 Set 集合类型属性</strong></p><p><strong>5、在集合里面设置对象类型值</strong></p><p><strong>6、把集合注入部分提取出来</strong></p></blockquote><p><strong>（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line"> <span class="comment">//1 数组类型属性</span></span><br><span class="line"> <span class="keyword">private</span> String[] courses;</span><br><span class="line"> <span class="comment">//2 list 集合类型属性</span></span><br><span class="line"> <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"> <span class="comment">//3 map 集合类型属性</span></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line"> <span class="comment">//4 set 集合类型属性</span></span><br><span class="line"> <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.sets = sets;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourses</span><span class="params">(String[] courses)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.courses = courses;</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.list = list;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.maps = maps;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）在 spring 配置文件进行配置（数组、list、map、set）：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>java 课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--list 类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>小三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--map 类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--set 类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>Redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="1、注入数组类型属性"><a href="#1、注入数组类型属性" class="headerlink" title="1、注入数组类型属性"></a>1、注入数组类型属性</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>java 课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、注入-List-集合类型属性"><a href="#2、注入-List-集合类型属性" class="headerlink" title="2、注入 List 集合类型属性"></a>2、注入 List 集合类型属性</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--list 类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>小三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3、注入-Map-集合类型属性"><a href="#3、注入-Map-集合类型属性" class="headerlink" title="3、注入 Map 集合类型属性"></a>3、注入 Map 集合类型属性</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--map 类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4、注入-Set-集合类型属性"><a href="#4、注入-Set-集合类型属性" class="headerlink" title="4、注入 Set 集合类型属性"></a>4、注入 Set 集合类型属性</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--set 类型属性注入--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>Redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="5、在集合里面设置对象类型值："><a href="#5、在集合里面设置对象类型值：" class="headerlink" title="5、在集合里面设置对象类型值："></a>5、在集合里面设置对象类型值：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多个 course 对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5 框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MyBatis 框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入 list 集合类型，值是对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="6、把集合注入部分提取出来："><a href="#6、把集合注入部分提取出来：" class="headerlink" title="6、把集合注入部分提取出来："></a>6、把集合注入部分提取出来：</h5><p><strong>（1）在 spring 配置文件中引入名称空间 util：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220613022422243.png" alt="image-20220613022422243"></p><p><strong>（2）使用 util 标签完成 list 集合注入提取：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 提取 list 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>易筋经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阴真经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阳神功<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2 提取 list 集合类型属性注入使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="IOC-操作-Bean-管理（FactoryBean）"><a href="#IOC-操作-Bean-管理（FactoryBean）" class="headerlink" title="IOC 操作 Bean 管理（FactoryBean）"></a>IOC 操作 Bean 管理（FactoryBean）</h4><blockquote><p>1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</p></blockquote><p><strong>普通 bean：</strong>在配置文件中定义 bean 类型就是返回类型<br><strong>工厂 bean：</strong>在配置文件定义 bean 类型可以和返回类型不一样</p><blockquote><p>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean </p><p>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Course&gt; &#123;</span><br><span class="line"> <span class="comment">//定义返回 bean</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Course <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>();</span><br><span class="line"> course.setCname(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> course;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>xml 配置：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.factorybean.MyBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>测试类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line"> <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class);</span><br><span class="line"> System.out.println(course);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IOC-操作-Bean-管理（bean-作用域）"><a href="#IOC-操作-Bean-管理（bean-作用域）" class="headerlink" title="IOC 操作 Bean 管理（bean 作用域）"></a>IOC 操作 Bean 管理（bean 作用域）</h4><p><strong>1、在 Spring 里面，设置创建 bean 实例是单实例还是多实例</strong></p><p><strong>2、在 Spring 里面，默认情况下，bean 是单实例对象</strong></p><blockquote><p>以下的内存地址相同</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220614094220607.png" alt="image-20220614094220607"></p><p><strong>3、如何设置单实例还是多实例</strong></p><blockquote><p>在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例</p></blockquote><p><strong>scope 属性值：</strong></p><ul><li><p>第一个值 默认值，singleton，表示是单实例对象</p></li><li><p>第二个值 prototype，表示是多实例对象</p></li></ul><blockquote><p>以下内存地址不同（多实例对象）：</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220614100243483.png" alt="image-20220614100243483"></p><p><strong>singleton 和 prototype 区别：</strong></p><blockquote><p><strong>singleton 单实例，prototype 多实例</strong></p><p>设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象</p><p>设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象</p></blockquote><h4 id="IOC-操作-Bean-管理（bean-生命周期）"><a href="#IOC-操作-Bean-管理（bean-生命周期）" class="headerlink" title="IOC 操作 Bean 管理（bean 生命周期）"></a>IOC 操作 Bean 管理（bean 生命周期）</h4><p><strong>生命周期：</strong></p><blockquote><p>从对象创建到对象销毁的过程</p></blockquote><p><strong>bean 生命周期：</strong></p><p>（1）通过构造器创建 bean 实例（无参数构造） </p><p>（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） </p><p>（3）调用 bean 的初始化的方法（需要进行配置初始化的方法） </p><p>（4）bean 可以使用了（对象获取到了） </p><p>（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p><blockquote><p>创建 –&gt; 赋值 –&gt; 初始化 –&gt; 使用 –&gt; 销毁</p></blockquote><p><strong>演示 bean 生命周期：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line"> <span class="comment">//无参数构造</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;第一步 执行无参数构造创建 bean 实例&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> String oname;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.oname = oname;</span><br><span class="line"> System.out.println(<span class="string">&quot;第二步 调用 set 方法设置属性值&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//创建执行的销毁的方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>xml 配置：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Orders&quot;</span> <span class="attr">initmethod</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>initmethod：</strong>初始化方法</p><p><strong>destroy-method：</strong>销毁方法</p></blockquote><blockquote><p>测试方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBean3</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line"> <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;orders&quot;</span>, Orders.class);</span><br><span class="line"> System.out.println(<span class="string">&quot;第四步 获取创建 bean 实例对象&quot;</span>);</span><br><span class="line"> System.out.println(orders);</span><br><span class="line"> <span class="comment">//手动让 bean 实例销毁</span></span><br><span class="line"> context.close();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>close() 是 AbstractApplicationContext 父类里面的方法</p></blockquote><blockquote><p>执行结果：</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220614101812206.png" alt="image-20220614101812206"> </p><p><strong>bean 的后置处理器，bean 生命周期有七步：</strong></p><p><strong>（1）</strong>通过构造器创建 bean 实例（无参数构造） </p><p><strong>（2）</strong>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） </p><p><strong>（3）</strong>把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization  </p><p><strong>（4）</strong>调用 bean 的初始化的方法（需要进行配置初始化的方法）</p><p><strong>（5）</strong>把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization </p><p><strong>（6）</strong>bean 可以使用了（对象获取到了） </p><p><strong>（7）</strong>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p><p><strong>演示添加后置处理器效果：</strong></p><blockquote><p>创建类，实现接口 BeanPostProcessor，创建后置处理器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>xml 配置：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置后置处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220614102632072.png" alt="image-20220614102632072"> </p><h4 id="IOC-操作-Bean-管理（xml-自动装配）"><a href="#IOC-操作-Bean-管理（xml-自动装配）" class="headerlink" title="IOC 操作 Bean 管理（xml 自动装配）"></a>IOC 操作 Bean 管理（xml 自动装配）</h4><p><strong>1、什么是自动装配：</strong></p><blockquote><p>根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入</p></blockquote><p><strong>2、演示自动装配过程：</strong></p><p>bean 标签属性 <strong>autowire</strong>，配置自动装配</p><blockquote><p>根据属性名称自动注入</p></blockquote><p><strong>autowire 属性常用两个值：</strong></p><p><strong>byName：</strong></p><blockquote><p> 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样</p></blockquote><p><strong>根据属性名称注入：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.autowire.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.autowire.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220614103808220.png" alt="image-20220614103808220"></p><p><strong>byType：</strong> </p><blockquote><p> 根据属性类型注入</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.autowire.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.autowire.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220614103639013.png" alt="image-20220614103639013"></p><h4 id="IOC-操作-Bean-管理-外部属性文件"><a href="#IOC-操作-Bean-管理-外部属性文件" class="headerlink" title="IOC 操作 Bean 管理(外部属性文件)"></a>IOC 操作 Bean 管理(外部属性文件)</h4><p><strong>一般作用：</strong></p><blockquote><p>直接配置数据库信息</p></blockquote><p><strong>演示Bean外部属性文件：</strong></p><p>（1）配置德鲁伊连接池 </p><p>（2）引入德鲁伊连接池依赖 jar 包</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220614104114686.png" alt="image-20220614104114686"> </p><p><strong>直接配置连接池：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--直接配置连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>引入外部属性文件配置数据库连接池：</strong></p><blockquote><p>（1）创建外部属性文件，properties 格式文件，写数据库信息</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220614104352642.png" alt="image-20220614104352642"></p><blockquote><p>（2）把外部 properties 属性文件引入到 spring 配置文件中</p></blockquote><p><strong>引入 context 名称空间：</strong></p><blockquote><p>跟引入 p 名称空间方法一致：</p></blockquote><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220615084218009.png"/><p><strong>在 spring 配置文件使用标签引入外部属性文件：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部属性文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="IOC-操作-Bean-管理-基于注解方式"><a href="#IOC-操作-Bean-管理-基于注解方式" class="headerlink" title="IOC 操作 Bean 管理(基于注解方式)"></a>IOC 操作 Bean 管理(基于注解方式)</h4><p><strong>1、什么是注解：</strong></p><p>（1）注解是代码特殊标记，格式：@注解名称(属性名称&#x3D;属性值, 属性名称&#x3D;属性值..) </p><p>（2）使用注解，注解作用在类上面，方法上面，属性上面 </p><p>（3）使用注解目的：简化 xml 配置</p><p><strong>2、Spring 针对 Bean 管理中创建对象提供注解：</strong></p><p>（1）@Component </p><p>（2）@Service </p><p>（3）@Controller </p><p>（4）@Repository</p><blockquote><p>上面四个注解功能是一样的，都可以用来创建 bean 实例</p></blockquote><p><strong>3、基于注解方式实现对象创建：</strong></p><blockquote><p> 第一步 引入依赖</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220615083916853.png" alt="image-20220615083916853"></p><blockquote><p>第二步 开启组件扫描</p></blockquote><ul><li>引入 context 名称空间</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220615084218009.png" alt="image-20220615084218009"></p><ul><li>写 xml 配置开启组件扫描</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描</span></span><br><span class="line"><span class="comment"> 1 如果扫描多个包，多个包使用逗号隔开</span></span><br><span class="line"><span class="comment"> 2 扫描包上层目录</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>base-package：扫描的范围</p></blockquote><blockquote><p>第三步 创建类，在类上面添加创建对象注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在注解里面 value 属性值可以省略不写，</span></span><br><span class="line"><span class="comment">//默认值是类名称，首字母小写</span></span><br><span class="line"><span class="comment">//UserService -- userService</span></span><br><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span> <span class="comment">//&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Component()括号里面value不写<strong>默认值是类名称，首字母小写</strong></p></blockquote><blockquote><p>4、开启组件扫描细节配置</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例 1</span></span><br><span class="line"><span class="comment"> use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter</span></span><br><span class="line"><span class="comment"> context:include-filter ，设置扫描哪些内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-defaultfilters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag"> </span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>use-defaultfilters&#x3D;”false”：不使用默认 filter，自己配置 filter</p><p>&lt;context:include-filter type&#x3D;”annotation” </p><p>expression&#x3D;”org.springframework.stereotype.Controller”&#x2F;&gt;：扫描所有带Controller注解的</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例 2</span></span><br><span class="line"><span class="comment"> 下面配置扫描包所有内容</span></span><br><span class="line"><span class="comment"> context:exclude-filter： 设置哪些内容不进行扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag"> </span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>&lt;context:exclude-filter type&#x3D;”annotation” </p><p>expression&#x3D;”org.springframework.stereotype.Controller”&#x2F;&gt;：扫描所有不带Controller注解的</p></blockquote><blockquote><p>5、基于注解方式实现属性注入与注解进行自动装配</p></blockquote><p><strong>（1）@Autowired：</strong></p><blockquote><p>根据属性类型进行自动装配</p></blockquote><ul><li><p>第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 </p></li><li><p>第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> <span class="comment">//定义 dao 类型属性</span></span><br><span class="line"> <span class="comment">//不需要添加 set 方法</span></span><br><span class="line"> <span class="comment">//添加注入属性注解</span></span><br><span class="line"> <span class="meta">@Autowired</span> </span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">  userDao.add();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>找到使用注解创建出来的相同类型的对象</p></blockquote><p><strong>（2）@Qualifier：</strong></p><blockquote><p>根据名称进行注入</p></blockquote><p>这个@Qualifier 注解的使用，和上面@Autowired 一起使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 dao 类型属性</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><blockquote><p> 找到使用注解创建出来的相同名称的对象</p></blockquote><p><strong>（3）@Resource：</strong></p><blockquote><p>可以根据类型注入，可以根据名称注入</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Resource //根据类型进行注入</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><p><strong>（4）@Value：</strong></p><blockquote><p> 注入普通类型属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><blockquote><p>6、完全注解开发</p></blockquote><p><strong>（1）创建配置类，替代 xml 配置文件：</strong></p><blockquote><p>代替了xml配置文件的组件扫描：</p><p>&lt;context:component-scan base-package&#x3D;”com.atguigu”&gt;&lt;&#x2F;context:component-scan&gt;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代 xml 配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>basePackages：有效范围</p></blockquote><p><strong>（2）编写测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService2</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//加载配置类</span></span><br><span class="line"> <span class="type">ApplicationContext</span> <span class="variable">context</span></span><br><span class="line"> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, </span><br><span class="line">UserService.class);</span><br><span class="line"> System.out.println(userService);</span><br><span class="line"> userService.add();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意这里的加载配置类：</strong></p><blockquote><p>加载配置类：ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-AOP</title>
      <link href="/kuailemao/97375e6e.html"/>
      <url>/kuailemao/97375e6e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="AOP（概念）"><a href="#AOP（概念）" class="headerlink" title="AOP（概念）"></a>AOP（概念）</h3><h4 id="1、什么是-AOP"><a href="#1、什么是-AOP" class="headerlink" title="1、什么是 AOP"></a>1、什么是 AOP</h4><p>（1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>（2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</p><p>（3）使用登录例子说明 AOP</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/%E5%9B%BE3.png" alt="图3"> </p><h4 id="AOP（底层原理）"><a href="#AOP（底层原理）" class="headerlink" title="AOP（底层原理）"></a>AOP（底层原理）</h4><p><strong>1、AOP 底层使用动态代理</strong></p><p>（1）有两种情况动态代理</p><p><strong>第一种 有接口情况，使用 JDK 动态代理</strong></p><ul><li>创建接口实现类代理对象，增强类的方法</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618174856814.png" alt="image-20220618174856814"></p><p><strong>第二种 没有接口情况，使用 CGLIB 动态代理</strong></p><ul><li>创建子类的代理对象，增强类的方法</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618174933224.png" alt="image-20220618174933224"></p><h4 id="AOP（JDK-动态代理）"><a href="#AOP（JDK-动态代理）" class="headerlink" title="AOP（JDK 动态代理）"></a>AOP（JDK 动态代理）</h4><p>1、使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618175023132.png" alt="image-20220618175023132"> </p><p><strong>（1）调用 newProxyInstance 方法</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618175053374.png" alt="image-20220618175053374"> </p><p><strong>方法有三个参数：</strong></p><p>第一参数，类加载器</p><p>第二参数，增强方法所在的类，这个类实现的接口，支持多个接口</p><p>第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p><p><strong>2、编写 JDK 动态代理代码</strong></p><p>（1）创建接口，定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建接口实现类，实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> a+b;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> id;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用 Proxy 类创建接口代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//创建接口实现类代理对象</span></span><br><span class="line"> Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line"><span class="comment">// Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, </span></span><br><span class="line"><span class="comment">// new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">// @Override</span></span><br><span class="line"><span class="comment">// public Object invoke(Object proxy, Method method, Object[] args) </span></span><br><span class="line"><span class="comment">// throws Throwable &#123;</span></span><br><span class="line"><span class="comment">// return null;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"> <span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"> <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> </span><br><span class="line">(UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao));</span><br><span class="line"> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建代理对象代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"> <span class="comment">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line"> <span class="comment">//有参数构造传递</span></span><br><span class="line"> <span class="keyword">private</span> Object obj;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.obj = obj;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//增强的逻辑</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> </span><br><span class="line">Throwable &#123;</span><br><span class="line"> <span class="comment">//方法之前</span></span><br><span class="line"> System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参</span></span><br><span class="line"><span class="string">数...&quot;</span>+ Arrays.toString(args));</span><br><span class="line"> <span class="comment">//被增强的方法执行</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"> <span class="comment">//方法之后</span></span><br><span class="line"> System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>以上为原生的  JDK 动态代理代码 ，Spring 的 AOP 对其进行了封装简化</p></blockquote><h4 id="AOP（术语）"><a href="#AOP（术语）" class="headerlink" title="AOP（术语）"></a>AOP（术语）</h4><p><strong>1、连接点</strong></p><blockquote><p>类里面哪些方法可以被增强，这些方法称为连接点</p></blockquote><p><strong>2、切入点</strong></p><blockquote><p>实际被真正增强的方法，称为切入点</p></blockquote><p><strong>3、通知（增强）</strong></p><p>（1）实际增强的逻辑部分称为通知（增强）</p><p>（2）通知有多种类型</p><ul><li>前置通知</li><li>后置通知</li><li>环绕通知</li><li>异常通知</li><li>最终通知</li></ul><p><strong>3.1、每一种通知的作用</strong></p><blockquote><p> 3.1 著作权归<a href="https://pdai.tech所有./">https://pdai.tech所有。</a> 链接：<a href="https://pdai.tech/md/spring/spring-x-framework-aop.html">https://pdai.tech/md/spring/spring-x-framework-aop.html</a></p></blockquote><p><strong>前置通知（Before advice）</strong>：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</p><p><strong>后置通知（After returning advice）</strong>：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p><p><strong>异常通知（After throwing advice）</strong>：在方法抛出异常退出时执行的通知。</p><p><strong>最终通知（After (finally) advice）</strong>：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p><p><strong>环绕通知（Around Advice）</strong>：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p><p><strong>4、切面</strong></p><blockquote><p>是动作</p></blockquote><p>把通知应用到切入点过程</p><h4 id="AOP-操作（准备工作）"><a href="#AOP-操作（准备工作）" class="headerlink" title="AOP 操作（准备工作）"></a>AOP 操作（准备工作）</h4><p><strong>1、Spring 框架一般都是基于 AspectJ 实现 AOP 操作</strong></p><p>（1）AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作</p><p><strong>2、基于 AspectJ 实现 AOP 操作</strong></p><p>（1）基于 xml 配置文件实现 </p><p>（2）基于注解方式实现（使用）</p><p><strong>3、在项目工程里面引入 AOP 相关依赖</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618180819822.png" alt="image-20220618180819822"> </p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618181142210.png" alt="image-20220618181142210"> </p><p><strong>4、切入点表达式</strong></p><p>（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强</p><p>（2）语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]( [参数列表]) )</p><p><strong>举例 1：</strong>对 com.atguigu.dao.BookDao 类里面的 add 进行增强 </p><p>execution(* com.atguigu.dao.BookDao.add(..))</p><p><strong>举例 2：</strong>对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 </p><p>execution(* com.atguigu.dao.BookDao.* (..))</p><p><strong>举例 3：</strong>对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 </p><p>execution(* com.atguigu.dao.<em>.</em> (..))</p><h4 id="AOP-操作（AspectJ-注解）"><a href="#AOP-操作（AspectJ-注解）" class="headerlink" title="AOP 操作（AspectJ 注解）"></a>AOP 操作（AspectJ 注解）</h4><p><strong>1、创建类，在类里面定义方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;add.......&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、创建增强类（编写增强逻辑）</strong></p><p>（1）在增强类里面，创建方法，让不同方法代表不同通知类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;<span class="comment">//前置通知</span></span><br><span class="line"> System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、进行通知的配置</strong></p><p>（1）在 spring 配置文件中，开启注解扫描</p><p>导入 context 名称空间：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618181833076.png" alt="image-20220618181833076"> </p><p>xml 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AOP操作--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuailemao.spring5.AOP&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）使用注解创建 User 和 UserProxy 对象</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618182025785.png" alt="image-20220618182025785"> </p><p>（3）在增强类上面添加注解 @Aspect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 创建对象</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）在 spring 配置文件中开启生成代理对象</p><p>导入 aop 名称空间：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618182215035.png" alt="image-20220618182215035"> </p><p>xml 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--生成Aspect生成代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4、配置不同类型的通知</strong></p><p>（1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 生成代理对象,说明它是代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="comment">// @Before注解表示作为前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.kuailemao.spring5.AOP.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defore</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beform....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知（有异常就不执行）</span></span><br><span class="line">    <span class="comment">// 返回值之后执行</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.kuailemao.spring5.AOP.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常通知，增强方法出现异常执行</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.kuailemao.spring5.AOP.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终通知</span></span><br><span class="line">    <span class="comment">// 无论正常或异常都在执行后执行</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* com.kuailemao.spring5.AOP.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知，方法之前和之后都执行</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.kuailemao.spring5.AOP.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之前...&quot;</span>);</span><br><span class="line">        <span class="comment">// 被增强的方法执行</span></span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//  int i = 10 / 0;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;add....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAop</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAopAnno</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beanAop.xml&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有出现异常的执行结果：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618182813909.png" alt="image-20220618182813909"> </p><p>出现异常的执行结果：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220618182935308.png" alt="image-20220618182935308"> </p><p><strong>5、相同的切入点抽取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用这个切入点时只需调用该方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//@Before 注解表示作为前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、有多个增强类多同一个方法进行增强，设置增强类优先级</strong></p><p>（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span>  <span class="comment">// 添加 @Order(1) 注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、完全使用注解开发</strong> </p><p>（1）创建配置类，不需要创建 xml 配置文件 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigAop</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在类的注解里面直接配置了，相当于开启扫描</p></blockquote><h4 id="AOP-操作（AspectJ-配置文件实现）"><a href="#AOP-操作（AspectJ-配置文件实现）" class="headerlink" title="AOP 操作（AspectJ 配置文件实现）"></a>AOP 操作（AspectJ 配置文件实现）</h4><p><strong>1、创建两个类，增强类和被增强类，创建方法</strong></p><p><strong>2、在 spring 配置文件中创建出两个类对象</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.aopxml.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.aopxml.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3、在 spring 配置文件中配置切入点</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置 aop 增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* </span></span></span><br><span class="line"><span class="string"><span class="tag">com.atguigu.spring5.aopxml.Book.buy(..))&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--增强作用在具体的方法上--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十、多线程</title>
      <link href="/kuailemao/51952628.html"/>
      <url>/kuailemao/51952628.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="🍖10、多-线-程"><a href="#🍖10、多-线-程" class="headerlink" title="🍖10、多 线 程"></a>🍖10、多 线 程</h3><h4 id="🍟10-1、了解多线程"><a href="#🍟10-1、了解多线程" class="headerlink" title="🍟10.1、了解多线程"></a>🍟10.1、了解多线程</h4><blockquote><p>世间万物每个个体都可以同时完成很多工作，这就是多线程</p></blockquote><h5 id="🍕10-1-1、进程与线程"><a href="#🍕10-1-1、进程与线程" class="headerlink" title="🍕10.1.1、进程与线程"></a>🍕10.1.1、进程与线程</h5><blockquote><p>进程是程序的一次动态执行过程，它是从代码加载、执行中到执行完毕的一个完整过程，也是进程本身从产生、发展到最终消亡的过程。</p></blockquote><p><strong>线程：（百度百科）</strong></p><blockquote><p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程<br>中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线<br>程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight &gt; processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p></blockquote><h5 id="🍕10-1-2、多线程的运行机制"><a href="#🍕10-1-2、多线程的运行机制" class="headerlink" title="🍕10.1.2、多线程的运行机制"></a>🍕10.1.2、多线程的运行机制</h5><blockquote><p>以往开发的程序大多是单线程的，即一个程序只有从开始到结束这一条执行路径。而多线程是指一个进程同时存在几条执行路径且并发执行的工作方式。</p></blockquote><p><strong>并发：</strong></p><blockquote><p>并发运行表示在一个处理器中，操作系统为了提高程序的运行效率，将 CPU 的执行时间分成多个时间片，分配给同一进程的不同线程。当执行完一个时间片后，当前运行的线程就可能交付出 CUP 权限，让其他线程执行下一个时间片，当然 CPU 也有可能将相邻的时间片分配给同一线程，即多个线程分享 CPU 时间，交替运行。</p></blockquote><blockquote><p>之所以从表面上看是多个线程同时运行的，是因为不同线程之间切换的时间非常短，也许仅仅是几毫秒，对普通人来说是难以感知的。</p></blockquote><h5 id="🍕10-1-3、多线程的优势"><a href="#🍕10-1-3、多线程的优势" class="headerlink" title="🍕10.1.3、多线程的优势"></a>🍕10.1.3、多线程的优势</h5><p><strong>多线程优势：</strong></p><blockquote><p>1、充分利用 CPU 的资源：运行单线程程序时，若程序发生阻塞，则 CPU 可能会处于空闲状态，这将造成计算机资源浪费。而使用多线程可以在某个线程处于休眠或阻塞状态时运行其他线程，这样将大大提高资源利用率。<br>2、简化编程模型：可以考虑将一个既长又复杂的进程分为多个线程，成为几个独立执行的模块。<br>3、良好的用户体验：由于多个线程可以交替运行，减少或避免了程序阻塞或意外情况造成的响应过慢现象，减少了用户等待时间，提升了用户体验。</p></blockquote><h4 id="🍟10-2、多线程编程"><a href="#🍟10-2、多线程编程" class="headerlink" title="🍟10.2、多线程编程"></a>🍟10.2、多线程编程</h4><blockquote><p>Java 语言提供了 java.lang.Thread 类支持多线程编程。</p></blockquote><h5 id="🍕10-2-1、Thread-类介绍"><a href="#🍕10-2-1、Thread-类介绍" class="headerlink" title="🍕10.2.1、Thread 类介绍"></a>🍕10.2.1、Thread 类介绍</h5><blockquote><p>Thread 类提供了大量的方法来控制和操作线程。</p></blockquote><p><strong>Thread 类常用方法：</strong></p><table><thead><tr><th>方法</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>Thread( )</td><td>创建 Thread 对象</td><td>构造方法</td></tr><tr><td>Thread(Runnable target)</td><td>创建 Thread 对象，target 为 run( ) 方法被调用的对象</td><td>构造方法</td></tr><tr><td>Thread(Runnable target,String name)</td><td>创建 Thread 对象，target 为 run( ) 方法被调用的对象,<br />name 为新线程的名称</td><td>构造方法</td></tr><tr><td>void run( )</td><td>执行任务操作的方法</td><td>实例方法</td></tr><tr><td>void start( )</td><td>使该线程开始运行，JVM 将调用该线程的 run( ) 方法</td><td>实例方法</td></tr><tr><td>void sleep(long millis)</td><td>在指定的毫秒数内让当前正在运行的线程休眠（暂停运行）</td><td>静态方法</td></tr><tr><td>Thread currentThread( )</td><td>返回当前线程对象的引用</td><td>静态方法</td></tr></tbody></table><p><strong>主线程：</strong></p><blockquote><p>public static void main( ) 方法是主线程的入口，每个进程至少有一个主线程。重要性如下：</p><ul><li>主线程是产生其他子线程的线程</li><li>主线程通常必须最后完成运行，因为它执行各种关闭动作。</li></ul><p>尽管主线程是自动创建的，但是可以由一个 Thread 对象控制。</p></blockquote><p><strong>获取主线程信息：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span>+t.getName());</span><br><span class="line">        t.setName(<span class="string">&quot;MainThread&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span>+t.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>实现线程方式：</strong></p><blockquote><p>Java 中有两种实现线程的方式：<br>1、继承 Thread 类<br>2、实现 Runnable 接口<br>分别重写 run( ) 方法，执行代码写在 run( ) 方法中</p></blockquote><h5 id="🍕10-2-2、继承-Thread-类创建线程类"><a href="#🍕10-2-2、继承-Thread-类创建线程类" class="headerlink" title="🍕10.2.2、继承 Thread 类创建线程类"></a>🍕10.2.2、继承 Thread 类创建线程类</h5><blockquote><p>继承 Thread 类是实现线程的一种方式。</p></blockquote><p><strong>满足条件：</strong></p><blockquote><ul><li>此类必须继承 Thread 类。</li><li>重写父类 run( ) 方法</li><li>将线程执行代码写在 run( ) 方法中。</li></ul></blockquote><p><strong>如下实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 Thread 类的方式创建自定义线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="comment">// 重写 run( ) 方法</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">// 线程执行任务的代码</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程的测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">// 使用 start() 方法启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">myThread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="🍕10-2-3、实现-Runnable-接口创建线程类"><a href="#🍕10-2-3、实现-Runnable-接口创建线程类" class="headerlink" title="🍕10.2.3、实现 Runnable 接口创建线程类"></a>🍕10.2.3、实现 Runnable 接口创建线程类</h5><blockquote><p>在使用继承 Thread 类的方式创建线程的过程中，子类无法再继承其他父类。因为 Java 不支持多继承。</p></blockquote><blockquote><p>可以通过实现 Runnable 接口的方式创建线程。这种方式更具有灵活性，用户线程还可以通过继承，再具有其他类的特性。</p></blockquote><blockquote><p>Runnable 接口位于 java.lang 包中，其中只提供了一个抽象方法 run( ) 声明，Thread 类也实现了 Runnable 接口。</p></blockquote><p><strong>如下实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口方式创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="comment">// 重写 run( ) 方法</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">// 线程执行任务的代码</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程的测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">// 使用 start() 方法启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">myThread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🍟10-3、线程的生命周期"><a href="#🍟10-3、线程的生命周期" class="headerlink" title="🍟10.3、线程的生命周期"></a>🍟10.3、线程的生命周期</h4><blockquote><p>新建的线程通常会在五种状态中转换，即：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/bfd7f1ce265b496e8e4d25129dc59ff0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><blockquote><p>画的好丑</p></blockquote><p><strong>1、新建状态：</strong></p><blockquote><p>一个 Thread 类或其子类的对象被声明并创建，但其在还未启动的这段时间里处于一种特殊的新建状态中。此时，线程类对象已经被分配了内存空间和资源，并且已被初始化，但是该线程尚未被调度。</p></blockquote><p><strong>2、就绪状态：</strong></p><blockquote><p>就绪状态也被称为可运行状态，处于新建状态的线程被启动后，也就是调用 start( ) 方法后，新建线程将进入线程队列，排队等待 CPU 时间片。此时它已具备运行的条件，一旦轮到它使用 CPU 资源，它就可以脱离创建它的主线程独立开始它的生命周期。</p></blockquote><p><strong>3、运行状态：</strong></p><blockquote><p>当就绪状态的进程被调度并获得处理器资源后便进入运行状态，该状态表示线程正在运行，该线程已经拥有了 CPU 的占用权。</p></blockquote><p>处于运行状态的线程在一下四种情况下会让出 CPU 的控制权：</p><ul><li>线程运行完毕</li><li>有比当前线程优先级更高的线程抢占了 CPU</li><li>线程休眠</li><li>线程因等待某个资源而处于阻塞状态。</li></ul><p><strong>4、阻塞状态：</strong></p><blockquote><p>一个正在运行的线程在某些特殊情况下需要让出 CPU 并暂时终止运行。这是，线程处于不可运行的状态被称为阻塞状态。</p></blockquote><p>例如：遇到 sleep 线程休眠进入线程阻塞状态</p><p><strong>5、死亡状态：</strong></p><blockquote><p>一个线程的 run( ) 方法运行完毕，表明该线程已死亡。处于死亡状态的线程不具有继续运行的能力。</p></blockquote><p>导致线程死亡的原因有两个：</p><ul><li>正常运行的线程完成了它的全部工作，即运行完 run( ) 方法的最后一条语句并退出；</li><li>当进程停止运行时，该线程中的所有线程将被强行终止。</li></ul><blockquote><p>线程处于死亡状态并且没有改线程的引用时，JVM 会从内存中删除该线程类对象。</p></blockquote><h4 id="🍟10-4、线程调度"><a href="#🍟10-4、线程调度" class="headerlink" title="🍟10.4、线程调度"></a>🍟10.4、线程调度</h4><h5 id="🍕10-4-1、线程调度相关方法"><a href="#🍕10-4-1、线程调度相关方法" class="headerlink" title="🍕10.4.1、线程调度相关方法"></a>🍕10.4.1、线程调度相关方法</h5><p><strong>常用的线程操作方法：</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>int getPriority( )</td><td>返回线程的优先级</td></tr><tr><td>void setPriority(int newPriority)</td><td>更改线程的优先级</td></tr><tr><td>boolean isAlive( )</td><td>测试线程是否处于活动状态</td></tr><tr><td>void join( )</td><td>进程中的其他线程必须等待该线程终止后才能运行</td></tr><tr><td>void interrupt( )</td><td>中断线程</td></tr><tr><td>void yield( )</td><td>暂停当前正在执行的线程类对象并运行其他线程</td></tr></tbody></table><h5 id="🍕10-4-2、线程的优先级"><a href="#🍕10-4-2、线程的优先级" class="headerlink" title="🍕10.4.2、线程的优先级"></a>🍕10.4.2、线程的优先级</h5><blockquote><p>Thread 类提供了 setPriority(int newPriority) 方法，getPriority( ) 方法用于设置和返回指定线程的优先级，其中 setPriority(int newPriority) 方法参数 newPriority 可以是一个整数，范围是 1~10；</p></blockquote><blockquote><p>也可以使用 Thread 类的如下三个静态常量设置线程的优先级：</p></blockquote><ul><li>MAX_PRIORITY：其值是 10 ，表示优先级最高。</li><li>MIN_PRIORITY：其值是 1，表示优先级最低。</li><li>NORM_PRIORITY：其值是 5，表示普通优先级。</li></ul><h4 id="🍟10-5、线程同步"><a href="#🍟10-5、线程同步" class="headerlink" title="🍟10.5、线程同步"></a>🍟10.5、线程同步</h4><blockquote><p>线程异步会出现对数据访问的安全问题，所以需要让线程同步来保证数据的访问安全性。</p></blockquote><h5 id="🍕10-5-1、实现线程的同步"><a href="#🍕10-5-1、实现线程的同步" class="headerlink" title="🍕10.5.1、实现线程的同步"></a>🍕10.5.1、实现线程的同步</h5><blockquote><p>当两个或多个线程需要访问同一资源时，需要以某种顺序来确保该资源某一时刻只能被一个线程使用，这被称为线程同步。</p></blockquote><h5 id="🍕1、同步代码块"><a href="#🍕1、同步代码块" class="headerlink" title="🍕1、同步代码块"></a>🍕1、同步代码块</h5><blockquote><p>代码块即使用 “{ }”括起来的一段代码，使用 synchronized 关键字修饰的代码块被称为同步代码块。</p></blockquote><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line"><span class="comment">//需要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果一个代码块带有 synchronized(obj) 标记，那么当线程执行此代码块使，必须先获得 obj 变量所引向的对象的锁，其可以针对任何代码块，并且可以任意指定上锁的对象，因此灵活性更高。</p></blockquote><h5 id="🍕2、同步方法"><a href="#🍕2、同步方法" class="headerlink" title="🍕2、同步方法"></a>🍕2、同步方法</h5><blockquote><p>如果一个方法的所有代码都属于需要同步的代码，那么这个方法定义处可以直接使用 synchronized 关键字修饰，即同步方法。</p></blockquote><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">synchronized</span> 访问修饰符 返回值类型 方法名(参数列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🍟10-6、线程同步的特征"><a href="#🍟10-6、线程同步的特征" class="headerlink" title="🍟10.6、线程同步的特征"></a>🍟10.6、线程同步的特征</h4><blockquote><p>所谓线程之间保持同步，是指不同的线程在执行以同一个对象作为锁标记的同步代码块或同步方法时，因为要获得这个对象的锁而相互牵制，线程同步具有以下特征：</p></blockquote><ul><li>当多个并发线程访问同一对象的同步代码块或同步方法时，同一时刻只能有一个线程运行，其他线程必须等待当前线程运行完毕后才能运行。</li><li>如果多个线程访问的不是同一共享资源，则无需同步。</li></ul><center>-----------------<b style="color:#C3C326">机遇永远是准备好的人得到的。</b>-----------------------</center>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九、IO流</title>
      <link href="/kuailemao/dd015c54.html"/>
      <url>/kuailemao/dd015c54.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="🍖9、I-x2F-O-流"><a href="#🍖9、I-x2F-O-流" class="headerlink" title="🍖9、I &#x2F; O 流"></a>🍖9、I &#x2F; O 流</h3><h4 id="🍟9-1、File-类"><a href="#🍟9-1、File-类" class="headerlink" title="🍟9.1、File 类"></a>🍟9.1、File 类</h4><blockquote><p>File 类是 java.io 包下代表操作与平台无关的文件和目录的类。可以通过 File 类实现对文件或目录的新建、删除、重命名等操作。</p></blockquote><p><strong>File 类的构造方法定义如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String pathName)</span></span><br></pre></td></tr></table></figure><p><strong>File 类的方法如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/3a4cc0959d6e42eeaa8ed5a1fed21f99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h4 id="🍟9-2、I-x2F-O-流概述"><a href="#🍟9-2、I-x2F-O-流概述" class="headerlink" title="🍟9.2、I &#x2F; O 流概述"></a>🍟9.2、I &#x2F; O 流概述</h4><blockquote><p>I &#x2F; O 流就是可以操作文件的一些 Java类，它们在 java.io 包下<br>I 即 input，指读取操作；O 即 output，指写出操作</p></blockquote><h5 id="🍕9-2-1、按流向划分：输入流和输入流"><a href="#🍕9-2-1、按流向划分：输入流和输入流" class="headerlink" title="🍕9.2.1、按流向划分：输入流和输入流"></a>🍕9.2.1、按流向划分：输入流和输入流</h5><blockquote><p>输入流：只能从中读取数据，而不能写入数据的流，实现程序从数据源中读操作。（从硬盘输入到内存）</p></blockquote><blockquote><p>输出流：只能向其写入数据，而不能从中读数据的流，实现程序向目标数据源中写数据。（从内存到硬盘）</p></blockquote><p>Java 的输入流主要以 inputStream 和 Reader 作为基类，而输出流则主要以 OutputStream 和 Writer 作为基类。它们都是一些抽象类，无法直接实例化对象。</p><h5 id="🍕9-2-2、按处理单元划分：字节流和字符流"><a href="#🍕9-2-2、按处理单元划分：字节流和字符流" class="headerlink" title="🍕9.2.2、按处理单元划分：字节流和字符流"></a>🍕9.2.2、按处理单元划分：字节流和字符流</h5><blockquote><p>字节流：以 8 位字节位为操作数据单元的流，可用于操作二进制数据。<br>字符流：以 16 位的字符为操作数据单元的流，可用于操作文本数据。</p></blockquote><p><strong>理解：</strong></p><blockquote><p>可以把 I &#x2F; O 流看作一个水管，这个水管中依次排列着许多水滴，每滴水滴就是一个处理单元，即一个字节或字符。在字节流中每滴水滴是一个字节，在字符流中每滴水滴是一个字符。</p></blockquote><h5 id="🍕9-2-3、按流的角色划分：节点流和处理流"><a href="#🍕9-2-3、按流的角色划分：节点流和处理流" class="headerlink" title="🍕9.2.3、按流的角色划分：节点流和处理流"></a>🍕9.2.3、按流的角色划分：节点流和处理流</h5><blockquote><p>节点流：可以直接向一个特定的存储介质（如磁盘、文件）读写数据的流。<br>处理流：用于对一个已存在的流进行连接和封装，是通过封装后的流实现数据读写操作的流。 </p></blockquote><p><strong>画图如下：</strong><br><img src="https://img-blog.csdnimg.cn/58e90735b4c9496481533112d99815b3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>ps：以上图片源于网络</p><h4 id="🍟9-3、字节流"><a href="#🍟9-3、字节流" class="headerlink" title="🍟9.3、字节流"></a>🍟9.3、字节流</h4><blockquote><p>java.io 包中的流按存储单元分类主要又字节流和字符流两大类，两类都具有输入&#x2F;输出操作。它们的基类如下图：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/d9c28248c2c145e080f07acbf7358bed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><blockquote><p>以上基类均为抽象类</p></blockquote><h5 id="🍕9-3-1、字节输出流基类：OutputSteam"><a href="#🍕9-3-1、字节输出流基类：OutputSteam" class="headerlink" title="🍕9.3.1、字节输出流基类：OutputSteam"></a>🍕9.3.1、字节输出流基类：OutputSteam</h5><blockquote><p>OutputStream 类为抽象类，必须使用该类的子类进行实例化对象。</p></blockquote><p><strong>OutputStream 类的方法如下：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/eea8430fb4444b2d90e74dc66470abfd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></blockquote><h5 id="🍕9-3-2、字节输出流-FileOutputStream-类"><a href="#🍕9-3-2、字节输出流-FileOutputStream-类" class="headerlink" title="🍕9.3.2、字节输出流 FileOutputStream 类"></a>🍕9.3.2、字节输出流 FileOutputStream 类</h5><blockquote><p>FileOutputStream 类是 OutputSteam 类的子类</p></blockquote><p><strong>FileOutputStream 构造方法：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/454a663ab86448f283a9d2c229dc6589.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></blockquote><p><strong>实现实例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符输出流（写）测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.创建文件输出流对象</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test2.txt&quot;</span>); <span class="comment">// 里面是文件路径</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.执行写操作</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;I love Java&quot;</span>; <span class="comment">//准备一个字符串</span></span><br><span class="line">            <span class="type">byte</span>[] words = str.getBytes();  <span class="comment">//将字符串转换为 byte 数组</span></span><br><span class="line">            fos.write(words,<span class="number">0</span>,words.length);</span><br><span class="line">            System.out.println(<span class="string">&quot;文件写入成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 4.关闭输出流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="🍕9-3-3、字节输入流基类：InputStream"><a href="#🍕9-3-3、字节输入流基类：InputStream" class="headerlink" title="🍕9.3.3、字节输入流基类：InputStream"></a>🍕9.3.3、字节输入流基类：InputStream</h5><blockquote><p>InputStream 类为抽象类，必须使用该类的子类进行实例化对象。</p></blockquote><p><strong>InputStream 类的方法如下：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/8bc4b10d854149cc9e0bd58022b216f3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></blockquote><h5 id="🍕9-3-4、字节输入流-FileInputStream-类"><a href="#🍕9-3-4、字节输入流-FileInputStream-类" class="headerlink" title="🍕9.3.4、字节输入流 FileInputStream 类"></a>🍕9.3.4、字节输入流 FileInputStream 类</h5><blockquote><p>通常使用 InputStream 类的 FileInputStream 子类实现文本文件内容的读取</p></blockquote><p><strong>FileInputStream 类构造方法如下：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/9469e4e8b66c434393f2128fd60983dc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></blockquote><p><strong>实现实例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节输入流（读）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.创建文件输入流对象</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test2.txt&quot;</span>); <span class="comment">// 里面是路径</span></span><br><span class="line">            System.out.println(<span class="string">&quot;可读取的字节数：&quot;</span>+fis.available());</span><br><span class="line">            <span class="comment">// 3.执行读操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 循环读取数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件内容：&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>((data = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 4.关闭输出流</span></span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以使用数组一次性读取多个字节。如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.创建文件输入流对象</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 3.执行读操作</span></span><br><span class="line">            <span class="type">byte</span>[] words = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];  <span class="comment">// 一次读取 1024 字节</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//实际读取长度</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件的内容：&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(words))!= -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(words,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                        fis.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="🍟9-4、字符流"><a href="#🍟9-4、字符流" class="headerlink" title="🍟9.4、字符流"></a>🍟9.4、字符流</h4><blockquote><p>在 Java 中，一个字符占用内存的两个字节。如果用字节流处理文本文件，则程序内部需要将字节转换成字符，减低了执行效率，所以当输入和输出文本文件时，尽量使用字符流。Java 提供了 Writer 类和 Reader 类来操作字符。</p></blockquote><h5 id="🍕9-4-1、字符输出流基类：Writer"><a href="#🍕9-4-1、字符输出流基类：Writer" class="headerlink" title="🍕9.4.1、字符输出流基类：Writer"></a>🍕9.4.1、字符输出流基类：Writer</h5><blockquote><p>Writer 类是字符输出流的抽象类。</p></blockquote><p><strong>Writer 类的方法如下：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/83856d115e174a93804d866e0e985b91.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></blockquote><h5 id="🍕9-4-2、字符输出流-FileWriter-类"><a href="#🍕9-4-2、字符输出流-FileWriter-类" class="headerlink" title="🍕9.4.2、字符输出流 FileWriter 类"></a>🍕9.4.2、字符输出流 FileWriter 类</h5><blockquote><p>FileWriter 类是 Writer 类常用的子类，使用该类可以以字符为数据处理单元向文本文件中写数据。</p></blockquote><p><strong>实现实例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符输出流 FileWriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建 FileWriter 对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;text.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 向文件写入数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;预测未来的最好方\n式就是创造未来！&quot;</span>);</span><br><span class="line">            fw.flush(); <span class="comment">// 刷新缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件写入成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123; <span class="comment">// 关闭流</span></span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="🍕9-4-3、字符输入流基类：Reader"><a href="#🍕9-4-3、字符输入流基类：Reader" class="headerlink" title="🍕9.4.3、字符输入流基类：Reader"></a>🍕9.4.3、字符输入流基类：Reader</h5><blockquote><p>Reader 类是字符输入流的基类，它是抽象类。</p></blockquote><p><strong>Reader 类的方法如下：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/0c43ce15926e456fb2020872956bc31e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></blockquote><h5 id="🍕9-4-4、字符输入流-FileReader"><a href="#🍕9-4-4、字符输入流-FileReader" class="headerlink" title="🍕9.4.4、字符输入流 FileReader"></a>🍕9.4.4、字符输入流 FileReader</h5><blockquote><p>Reader 类同样是抽象类，可以使用其子类 FileReader 创建对象。</p></blockquote><p><strong>实现实例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 2.实例化 FileReader 对象</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;text.txt&quot;</span>);</span><br><span class="line">            <span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>]; <span class="comment">//字符使用 char 数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 保存实际存储的字符数</span></span><br><span class="line">            <span class="comment">// 3.循环读取数据</span></span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(ch)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 4.关闭流</span></span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="🍟9-5、缓冲流"><a href="#🍟9-5、缓冲流" class="headerlink" title="🍟9.5、缓冲流"></a>🍟9.5、缓冲流</h4><blockquote><p>java.io 包提供了缓冲流，缓冲流属于处理流。</p></blockquote><h5 id="🍕9-5-1、字符缓冲输出流-BufferedWriter-类"><a href="#🍕9-5-1、字符缓冲输出流-BufferedWriter-类" class="headerlink" title="🍕9.5.1、字符缓冲输出流 BufferedWriter 类"></a>🍕9.5.1、字符缓冲输出流 BufferedWriter 类</h5><blockquote><p>BufferedWriter 类是 Writer 类的子类，BufferedWriter 类可以把一批数据写到缓冲区，默认情况下，只有在缓冲区满的时候，才会把缓冲区的数据真正写到目的地，这样能减少物理写数据的次数，从而提高 I&#x2F;O 操作的执行效率。</p></blockquote><p><strong>BufferedWriter 类的构造方法如下：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/3ad6cbe55c8c45adb35cc48540297dee.png#pic_center" alt="在这里插入图片描述"></p></blockquote><p><strong>实现实例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符缓冲输出流 BufferedWriter 类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建 FileWriter 对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;BufferedWriter.txt&quot;</span>);</span><br><span class="line">            bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">            <span class="comment">// 向文件中写数据</span></span><br><span class="line">            bw.write(<span class="string">&quot;亲爱的小伙伴们：&quot;</span>);</span><br><span class="line">            bw.newLine();   <span class="comment">//换行</span></span><br><span class="line">            bw.write(<span class="string">&quot;让我们来使用缓冲流让程序加速吧！&quot;</span>);</span><br><span class="line">            bw.flush(); <span class="comment">// 刷新</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件写入成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>从以上可以看出，创建 BufferedWriter 对象需要借助一个 Writer 对象，在该对象的基础上进一步封装，成为一个带缓冲区的字符输出流。</p></blockquote><h5 id="🍕9-5-2、字符缓冲输入流-BufferedReader-类"><a href="#🍕9-5-2、字符缓冲输入流-BufferedReader-类" class="headerlink" title="🍕9.5.2、字符缓冲输入流 BufferedReader 类"></a>🍕9.5.2、字符缓冲输入流 BufferedReader 类</h5><blockquote><p>BufferedReader 类是 Reader 类的子类，它与 FileReader 类的区别在于 BufferedReader 类有缓冲区，它可以把一批数据读到缓冲区中，接下来的读操作都是从缓冲区内获取数据，避免每次都从数据源读取数据进行字符编码转换，从而提高读取操作的效率。</p></blockquote><p><strong>BufferedReader 类的构造方法如下；</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/d5598e68d3f84dc993e3601e08fe2a6d.png#pic_center" alt="在这里插入图片描述"></p></blockquote><p><strong>实现实例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带缓冲区的字符输入流 BufferedReader 类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;BufferedWriter.txt&quot;</span>);</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="keyword">while</span>(line != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">                line = br.readLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">                br.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>从以上可以看出，创建 BufferedReader对象需要借助一个 Reader对象，在该对象的基础上进一步封装，成为一个带缓冲区的字符输入流。</p></blockquote><h4 id="🍟9-6、数据操作流"><a href="#🍟9-6、数据操作流" class="headerlink" title="🍟9.6、数据操作流"></a>🍟9.6、数据操作流</h4><blockquote><p>可以对二进制文件的读写操作</p></blockquote><h5 id="🍕9-6-1、DataOutputStream-类和-DataInputStream-类"><a href="#🍕9-6-1、DataOutputStream-类和-DataInputStream-类" class="headerlink" title="🍕9.6.1、DataOutputStream 类和 DataInputStream 类"></a>🍕9.6.1、DataOutputStream 类和 DataInputStream 类</h5><blockquote><p>DataOutputStream 类是 OutputStream 类的子类，利用 DataOutputStream 类写二进制文件的实现步骤与使用 FileOutputStream 类写文件的步骤及其相似，而且用到了 FileOutputStream 类。<br>同样：DataInputStream 类是 InputStream 类的子类，在使用上也与 FileInputStream 类很相似。</p></blockquote><p><strong>使用实例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据操作流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataInOutTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建 输入流文件</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\User.class&quot;</span>);</span><br><span class="line">            dis = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fis);</span><br><span class="line">            <span class="comment">// 创建输出流文件</span></span><br><span class="line">     fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Demo/newUser.class&quot;</span>);</span><br><span class="line">            dos = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fos);</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            <span class="keyword">while</span>((temp = dis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    fos.write(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123; <span class="comment">// 关闭</span></span><br><span class="line">            <span class="keyword">if</span> (dis != <span class="literal">null</span>) &#123;</span><br><span class="line">                dis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dos != <span class="literal">null</span>) &#123;</span><br><span class="line">                dos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="🍟9-7、序列化与反序列化"><a href="#🍟9-7、序列化与反序列化" class="headerlink" title="🍟9.7、序列化与反序列化"></a>🍟9.7、序列化与反序列化</h4><blockquote><p>将对象的信息保存到磁盘中便于以后检索。可以将对象中的属性信息逐一记录到文本文件中（序列化），还需要再使用的时候还原（反序列化）。</p></blockquote><blockquote><p>序列化的对象保存的是二进制状态，这样实现了平台无关性，可以将在 Windows 操作系统中实现序列化的一个对象，传输到 Linux 操作系统的机器上。反序列化是将特定的存储介质中的数据重新构建对象的过程，通过发序列化后得到相同对象，而无序担心数据因平台不同出现异常。</p></blockquote><p><strong>序列化和反序列化过程：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/19eb99b4385d428b8dadb9f24111a670.png#pic_center" alt="在这里插入图片描述"></p></blockquote><blockquote><p>实现序列化和反序列化操作，需要使用对象操作流：</p><p>对象输出流：ObjectOutputStream</p><p>对象输入流：ObjectInputStream</p></blockquote><h5 id="🍕9-7-1、对象输出流-ObjectOutputStream-实现序列化"><a href="#🍕9-7-1、对象输出流-ObjectOutputStream-实现序列化" class="headerlink" title="🍕9.7.1、对象输出流 ObjectOutputStream 实现序列化"></a>🍕9.7.1、对象输出流 ObjectOutputStream 实现序列化</h5><blockquote><p>可以理解为把一个对象变为二进制的数据流的一种方法，通过对象序列化可以方便的实现对象的传输和存储。</p></blockquote><blockquote><p>一个类需要被序列化，则这个对象所属类必须实现 java.io.Serializable 接口，接口如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>序列化版本号：</strong></p><blockquote><p>对象序列化和反序列化操作时可能会遇到版本兼容性问题，要考虑 JDK 版本，版本不一致就可能发生错误。<br>所以在序列化操作中引入了一个 serialVersionUID 的常量（序列化版本号），可以通过此常量验证版本的一致性。<br>当实现 java.io.Serializable 接口的类没有显式定义名为 serialVersionUID、类型为 long 的变量时，java 序列化机制在编译时会自动生成一个此版本的 serialVersionUID 变量。如果不希望通过编译自动生成，可以直接自己显式定义这个变量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; (<span class="number">1L</span>为自己定义的版本号)</span><br></pre></td></tr></table></figure><p><strong>ObjectOutputStream 类的常用方法：</strong></p><table><thead><tr><th>方法名</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>ObjectOutputStream(OutputStream out)</td><td>创建对象输出流对象</td><td>构造方法</td></tr><tr><td>final void writeObject(Object obj)</td><td>将指定对象写入流</td><td>实例方法</td></tr></tbody></table><p><strong>实现实例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化与反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建 ObjectOutputStream    输出流</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;杰米&quot;</span>,<span class="number">25</span>,<span class="string">&quot;男&quot;</span>); <span class="comment">// Person 类实现了 Serializable 接口</span></span><br><span class="line">            <span class="comment">// 对象序列化，写入数据</span></span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            System.out.println(<span class="string">&quot;序列化成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>也可以使用集合一次性保存多个对象</p></blockquote><h5 id="🍕9-7-2、对象输入流-ObjectInputStream-实现反序列化"><a href="#🍕9-7-2、对象输入流-ObjectInputStream-实现反序列化" class="headerlink" title="🍕9.7.2、对象输入流 ObjectInputStream 实现反序列化"></a>🍕9.7.2、对象输入流 ObjectInputStream 实现反序列化</h5><blockquote><p>ObjectInputStream 它可以直接把序列化后的对象还原。</p></blockquote><p><strong>ObjectInputStream 常用方法：</strong></p><table><thead><tr><th>方法</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>ObjectInputStream(InputStream in)</td><td>创建对象输入流对象</td><td>构造方法</td></tr><tr><td>final Object readObject( )</td><td>从指定位置读取对象</td><td>实例方法</td></tr></tbody></table><p><strong>实现实例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Demo/person.txt&quot;</span>));</span><br><span class="line">                <span class="comment">// 反序列化，进行强制类型转换</span></span><br><span class="line">                <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">                <span class="comment">// 输出转换反序列化后的对象信息</span></span><br><span class="line">                per.print();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ois != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ois.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>如果使用序列化方式向文件中写入多个对象，那么反序列化恢复对象时，也按照写入的顺序读取。</p></blockquote><h5 id="🍕9-7-3、transient-关键字"><a href="#🍕9-7-3、transient-关键字" class="headerlink" title="🍕9.7.3、transient 关键字"></a>🍕9.7.3、transient 关键字</h5><blockquote><p>如果希望对象中的某个属性不被序列化，只需在某个类中的属性前添加 transient 关键字，如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;</span><br></pre></td></tr></table></figure><blockquote><p>age 属性将不会参与序列化</p></blockquote><h5 id="🍕9-7-4、Java-体系中常用流总结"><a href="#🍕9-7-4、Java-体系中常用流总结" class="headerlink" title="🍕9.7.4、Java 体系中常用流总结"></a>🍕9.7.4、Java 体系中常用流总结</h5><blockquote><p>Java 中常用的流总结如下：</p></blockquote><table><thead><tr><th>分类</th><th>字节输出流</th><th>字节输入流</th><th>字符输出流</th><th>字符输入流</th></tr></thead><tbody><tr><td>基类</td><td>OutputStream</td><td>InputStream</td><td>Writer</td><td>Reader</td></tr><tr><td>文件流</td><td>FileOutputStream</td><td>FileInputStream</td><td>FileWriter</td><td>FileReader</td></tr><tr><td>缓冲流</td><td>BufferedOutputStream</td><td>BufferedInputStream</td><td>BufferedWriter</td><td>BufferedReader</td></tr><tr><td>对象流</td><td>ObjectOutputStream</td><td>ObjectInputStream</td><td>——</td><td>——</td></tr><tr><td>数据操作流</td><td>DataOutputStream</td><td>DataInputStream</td><td>——</td><td>——</td></tr></tbody></table><blockquote><p>所有的基类都是抽象类，无法直接创建实例，需要借助其实现类</p></blockquote><blockquote><p>所有的输出流用于实现写数据操作，所有的输入流用于实现读取操作。这个输入和输出是相对程序而言的。</p></blockquote><blockquote><p>所有的文件流直接与存储介质关联，也就是需指定物理节点，属于节点流，其他流的创建需要在节点流的基础上进行封装，使其具有特殊的功能。</p></blockquote><blockquote><p>在操作文本文件时，应使用字符流。字节流可以处理二进制数据，它的功能比字符流更强大。</p><p>因为计算机所有的数据都是二进制数据，如果用字节流处理文本文件，还需要把这些字节转换成字符，就增加了编程的复杂度，减低了执行效率。所以当输入和输出是文本文件时，尽量使用字符流。如果是二进制文本，则应考虑使用节点流。</p></blockquote><center>-----------------<b style="color:#C3C326">努力造就实力，态度决定高度。</b>-----------------------</center>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、包装类</title>
      <link href="/kuailemao/ee01465e.html"/>
      <url>/kuailemao/ee01465e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="🍖8、包装类"><a href="#🍖8、包装类" class="headerlink" title="🍖8、包装类"></a>🍖8、包装类</h3><blockquote><p>Java 包含八种基本数据类型，同时包含与其对应的包装类。</p></blockquote><blockquote><p>这些包装类存在于 java.lang 包中，关系图如下：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/bd3a3a5576354adf88163970c4063981.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><strong>其中：</strong></p><blockquote><p>所有数字类型包装类都继承 Number 类，Number 类是一个抽象类。<br>Number 类包装了 Byte、Short、Interger、Long、Float、Double 等数字类型，并且实现其所定义的方法，这些方法以不同的数字格式返回对象的值。</p></blockquote><h4 id="🍟8-1、包装类和基本数据类型的转换"><a href="#🍟8-1、包装类和基本数据类型的转换" class="headerlink" title="🍟8.1、包装类和基本数据类型的转换"></a>🍟8.1、包装类和基本数据类型的转换</h4><h5 id="🍕8-1-1、基本数据类型转换为包装类"><a href="#🍕8-1-1、基本数据类型转换为包装类" class="headerlink" title="🍕8.1.1、基本数据类型转换为包装类"></a>🍕8.1.1、基本数据类型转换为包装类</h5><blockquote><p>在 Java 中，基于基本数据类型数据创建包装类对象通常可用采用如下两种方式：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Type</span><span class="params">(type value)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Type</span><span class="params">(String value)</span></span><br></pre></td></tr></table></figure><blockquote><p>其中，Type 表示包装类，参数 type 为基本数据类型。</p></blockquote><p><strong>如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本数据类型向包装类转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bl</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 1.通过构造方法现基本数据类型向包装类转换</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">blObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(bl);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">itOBj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">35</span>);</span><br><span class="line">        <span class="type">Character</span> <span class="variable">chOBJ</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        System.out.println(blObj+<span class="string">&quot;,&quot;</span>+itOBj+<span class="string">&quot;,&quot;</span>+chOBJ);</span><br><span class="line">        <span class="comment">// 2.将字符串转换为 Boolean 对象</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">bOBj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">bOBj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;TRue&quot;</span>);    <span class="comment">// 不区分大小写</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">bOBj3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>);    <span class="comment">// 非 true 即 false</span></span><br><span class="line">        System.out.println(bOBj+<span class="string">&quot;,&quot;</span>+bOBj2+<span class="string">&quot;,&quot;</span>+bOBj3);</span><br><span class="line">        <span class="comment">// 运行时将出现 java.lang.NumberFormatException 异常</span></span><br><span class="line">        <span class="comment">// Long lObj = new Long(&quot;hello&quot;);</span></span><br><span class="line">        <span class="comment">// Char 型数据不能使用字符串构造包装类对象</span></span><br><span class="line">        <span class="comment">// Character chobj2 = new Character(&#x27;男&#x27;);；</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>true,35,男<br>true,true,true</p></blockquote><h5 id="🍕8-1-2、包装类转换为基本数据类型"><a href="#🍕8-1-2、包装类转换为基本数据类型" class="headerlink" title="🍕8.1.2、包装类转换为基本数据类型"></a>🍕8.1.2、包装类转换为基本数据类型</h5><blockquote><p>包装类转换为基本数据类型通常采用如下方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> type <span class="title function_">typeValue</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>其中：type 指的是基本数据类型，如 byteValue( )、charValue( )、相应的返回值为 byte、char。将包装类对象转换为基本数据类型。</p></blockquote><p><strong>如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 包装类转换为基本数据类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">bl</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 通过构造器实现基本数据类型向包装类转换</span></span><br><span class="line">          <span class="type">Boolean</span> <span class="variable">blObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(bl);</span><br><span class="line">          <span class="type">Integer</span> <span class="variable">itObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">35</span>);</span><br><span class="line">          <span class="type">Character</span> <span class="variable">chObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">          <span class="comment">// 包装类转换为基本数据类型</span></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blObj.booleanValue();</span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> itObj.intValue();</span><br><span class="line">          <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> chObj.charValue();</span><br><span class="line">          System.out.println(b1+<span class="string">&quot;,&quot;</span>+i+<span class="string">&quot;,&quot;</span>+ch);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>true,35,男</p></blockquote><p><strong>关系图：</strong></p><p><img src="https://img-blog.csdnimg.cn/5aeb702adce04f81915100bf70d57aa3.png#pic_center" alt="在这里插入图片描述"></p><h4 id="🍟8-2、装箱拆箱"><a href="#🍟8-2、装箱拆箱" class="headerlink" title="🍟8.2、装箱拆箱"></a>🍟8.2、装箱拆箱</h4><blockquote><p>Java 基本数据类型变量和包装类对象之间的转换较繁琐，从 JDK1.5 之后提供了自动装箱（Autoboxing）和自动拆箱（AutoUnboxing）机制</p></blockquote><ul><li>自动装箱：把基本数据类型变量直接转换为对应的包装类对象，或者转换为 Object 对象。</li><li>自动拆箱：与装箱相反，将包装类对象转换成对应的基本数据类型变量</li></ul><p><strong>如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxTest</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="comment">// 基本数据类型变量转换为包装类（装箱）</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">inObj</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">boolObj</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            System.out.println(inObj+<span class="string">&quot;,&quot;</span>+boolObj);</span><br><span class="line">            <span class="comment">// 包装类转换为基本数据类型（拆箱）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">it</span> <span class="operator">=</span> inObj;</span><br><span class="line">            System.out.println(it);</span><br><span class="line">            <span class="keyword">if</span>(boolObj <span class="keyword">instanceof</span> Boolean)&#123;</span><br><span class="line">                <span class="comment">// 先把 Object 对象强制转换为 Boolean 类型，再赋值给 boolean 变量</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> (Boolean)boolObj;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>5,true<br>5<br>true</p></blockquote><center>-----------------<b style="color:#C3C326">行动是理想最高贵的表达。</b>-----------------------</center>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、集合框架</title>
      <link href="/kuailemao/d30dd4b2.html"/>
      <url>/kuailemao/d30dd4b2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="🍖7、集合框架"><a href="#🍖7、集合框架" class="headerlink" title="🍖7、集合框架"></a>🍖7、集合框架</h3><blockquote><p>Java 集合位于 java.util 包中,集合中的元素全部是对象,及 Object 实例,不同的集合类有不同的功能和特点,适合不同的场合。</p></blockquote><h4 id="🍟7-1、集合结构"><a href="#🍟7-1、集合结构" class="headerlink" title="🍟7.1、集合结构"></a>🍟7.1、集合结构</h4><p><strong>集合的继承结构：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/6ba054c5b6cf4081b9c99c7698d938df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="集合继承结构"></p></blockquote><p>ps:上图源自于网络</p><blockquote><p>Java 的集合类主要由两个接口派生而成：Collection 接口和 Map 接口。Collection 接口和 Map 接口是 Java 集合框架的根接口，其中，Collection 接口常用的子接口包含 List 接口和 Set 接口；<br>Map 接口是独立的</p></blockquote><p><strong>Java 集合框架常用接口：</strong></p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Collection</td><td>* 单值集合的根接口，是最基本的集合接口。<br />* 一个 Collection 代表一组 Object。Java 不提供实现类，只提供子接口（如 List 接口和 Set 接口）。<br />* Collection 接口存储一组可重复的无序对象。</td></tr><tr><td>Set</td><td>* 继承 Collection 接口，存储一组不可重复的无序对象（无序不重复）。</td></tr><tr><td>List</td><td>* 继承 Collection 接口，储存一组可重复的有序对象。<br />* 元素顺序以元素插入的次序来放置元素，不会重新排序。<br />* 通过索引访问数组元素，索引从0开始。<br />* List 接口常用的实现类有 ArrayList 类和 LinkedList 类。</td></tr><tr><td>Map</td><td>* 存储成对数据的根接口，可存储一组 “键-值对” 对象。<br />* 提供键（key）到值（value）的映射，Map 中的键不要求有序，不允许重复。值同样不要求有序，但允许重复。<br />* 可以通过键找到对应的值。</td></tr><tr><td>Iterator</td><td>集合迭代器，能够遍历集合元素的接口</td></tr><tr><td>Collections</td><td>* 与 Collection 是不同的概念，它提供了对集合对象进行基本操作的通用接口方法。<br />* 包含各种有关集合操作的静态方法。<br />* 一个工具类，不能实例化。</td></tr></tbody></table><h5 id="🍕7-1-2、Collection-接口"><a href="#🍕7-1-2、Collection-接口" class="headerlink" title="🍕7.1.2、Collection 接口"></a>🍕7.1.2、Collection 接口</h5><blockquote><p>Collection 接口是 List 接口、Set 接口的父接口，该接口中定义的方法即可用于操作 Set 集合，也可用户操作 List 集合。</p></blockquote><p><strong>Collection 接口常用方法：</strong></p><p><img src="https://img-blog.csdnimg.cn/0c43cce0fea84f0c9ae50a0916aa2c47.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>ps:详细自行查找 API<br><strong>注意：</strong></p><blockquote><p>Java 集合中的元素全部是对象，是引用类型，不能存储基本数据类型元素。如果强制添加，则会自动封装成对象（自动装箱，自动拆箱）。</p></blockquote><h4 id="🍟7-2、List"><a href="#🍟7-2、List" class="headerlink" title="🍟7.2、List"></a>🍟7.2、List</h4><blockquote><p>List 集合是一类存储元素有序，可重复的集合，集合中每个元素都有其对应的索引。List 集合允许使用重复元素，通过索引访问元素。</p></blockquote><h5 id="🍕7-2-1、List-概述"><a href="#🍕7-2-1、List-概述" class="headerlink" title="🍕7.2.1、List 概述"></a>🍕7.2.1、List 概述</h5><blockquote><p>List 接口作为 Collection 接口的子接口，可以使用 Collection 接口定义的全部方法。<br>List 接口在 Collection 接口方法的基础上，另外扩展了一些根据索引操作集合元素的方法。</p></blockquote><p><strong>List 接口扩展的方法：</strong></p><p><img src="https://img-blog.csdnimg.cn/a124c84a3b6e49bc8a7dac991ba716fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h5 id="🍕7-2-2、ArrayList-集合类"><a href="#🍕7-2-2、ArrayList-集合类" class="headerlink" title="🍕7.2.2、ArrayList 集合类"></a>🍕7.2.2、ArrayList 集合类</h5><blockquote><p>继承 List 接口，底层数组，可通过索引访问元素</p></blockquote><p><strong>ArrayList 集合的基本使用如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1.1、每个集合对象的创建（new）</span></span><br><span class="line"><span class="comment">       1.2、向集合中添加元素</span></span><br><span class="line"><span class="comment">       1.3、从集合中取出某个元素</span></span><br><span class="line"><span class="comment">       1.4、遍历集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListTest</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="comment">// 创建ArrayList集合</span></span><br><span class="line">           ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="comment">// 向集合添加元素</span></span><br><span class="line">           arrayList.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">           arrayList.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">           arrayList.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">           arrayList.add(<span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">           <span class="comment">// 从集合中取出某个元素</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> arrayList.get(<span class="number">1</span>);</span><br><span class="line">           System.out.println(i);</span><br><span class="line">           System.out.println(<span class="string">&quot;===============分割线============&quot;</span>);</span><br><span class="line">           <span class="comment">// 遍历集合 获取迭代器进行集合遍历</span></span><br><span class="line">           Iterator&lt;String&gt; it = arrayList.iterator();</span><br><span class="line">           <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">               System.out.print(it.next()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;\n===============分割线============&quot;</span>);</span><br><span class="line">           <span class="comment">// 遍历集合 通过迭代器配合for循环遍历</span></span><br><span class="line">           <span class="keyword">for</span>(Iterator&lt;String&gt; its = arrayList.iterator() ;its.hasNext();)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;====&gt;&quot;</span>+its.next());</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;===============分割线=============&quot;</span>);</span><br><span class="line">           <span class="comment">// 遍历集合 通过增强for</span></span><br><span class="line">           <span class="keyword">for</span>(String fors : arrayList)&#123;</span><br><span class="line">               System.out.print(fors+<span class="string">&quot; &quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;\n===============分割线=============&quot;</span>);</span><br><span class="line">           <span class="comment">// 遍历集合 通过获取长度加for的方式</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arrayList.size();j++)&#123;</span><br><span class="line">               System.out.print(arrayList.get(j)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/7fe5a3d938d84ad3bb28738c15ca1664.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></blockquote><p><strong>总结：</strong></p><blockquote><p>ArrayList 集合底层采用数组的数据结构<br>ArrayList 集合是非线程安全的<br>1、ArrayList 集合初始化容量是 10<br>2、ArrayList 集合底层是 Object 类型的数组 Object[ ]<br>3、扩容到原容量的 1.5 倍<br>4、建议给定一个预估计的初始化容量，减少数组的扩容次数，这是 ArrayList 集合比较重要的优化策略。<br>5、数组的优点：检索效率比较高<br>6、数组的缺点：随机增删元素效率比较低<br>7、需要注意的是：向数组末尾添加元素，效率还是很高的 </p></blockquote><h5 id="🍕7-2-3、LinkedList-集合类"><a href="#🍕7-2-3、LinkedList-集合类" class="headerlink" title="🍕7.2.3、LinkedList 集合类"></a>🍕7.2.3、LinkedList 集合类</h5><blockquote><ul><li>ArrayList集合 采用了和数组相同的存储方式，在内存中分配连续的空间，当添加和删除非尾部元素时会导致后面所有元素的移动，性能低下，所以在插入，删除操作比较频繁时，可以考虑使用LinkedList 集合提高效率。</li><li>LinkedList 类是 List 接口的实现类，这就意味着 LinkedList 集合和 ArrayList 集合都是一个 List 集合，可以根据所以随机访问集合中的元素。</li><li>LinkedList 集合具有 双向链表结构，更加方便实现添加和删除操作。</li></ul></blockquote><p><strong>LinkedList 集合方法如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/06250fa22b4d4afab8b869d65bbbda53.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><strong>LinkedList 集合存储数据与遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 LinkedList 集合存储数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建集合及元素对象</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">fruits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;香水梨&quot;</span>,<span class="number">2.5</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;苹果梨&quot;</span>,<span class="number">2.0</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;富士苹果&quot;</span>,<span class="number">3.5</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;金帅苹果&quot;</span>,<span class="number">3.0</span>);</span><br><span class="line">        <span class="comment">//2.向集合中添加元素</span></span><br><span class="line">        fruits.add(fruit1);</span><br><span class="line">        fruits.add(fruit2);</span><br><span class="line">        fruits.add(fruit3);</span><br><span class="line">        fruits.add(fruit4);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中包含水果信息如下：&quot;</span>);</span><br><span class="line">        shoData(fruits);</span><br><span class="line">        <span class="comment">// 3.查看集合中第一条水果信息</span></span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">firstFruit</span> <span class="operator">=</span> (Fruit) ((LinkedList) fruits).getFirst();</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中第一类水果：&quot;</span>+firstFruit.getBrand());</span><br><span class="line">        <span class="comment">// 5.删除集合中第一条和最后一条信息</span></span><br><span class="line">        fruits.removeFirst();</span><br><span class="line">        fruits.removeLast();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除部分信息后还有&quot;</span>+fruits.size()+<span class="string">&quot;条水果信息。如下：&quot;</span>);</span><br><span class="line">        shoData(fruits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * for 循环遍历集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shoData</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> (Fruit) list.get(i);</span><br><span class="line">            fruit.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>水果类基本结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;   <span class="comment">// 水果品种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;   <span class="comment">// 价格</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略 setter and getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fruit</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fruit</span><span class="params">(String brand, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.brand+<span class="string">&quot;,每斤&quot;</span>+<span class="built_in">this</span>.price+<span class="string">&quot;元。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/3d61fcb85e2a410cb5d8db844e27d97f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></blockquote><p><strong>总结：</strong></p><blockquote><p>LinkedList 集合底层采用双向链表数据结构<br>1、LinkedList 集合是双向链表。<br>2、对于链表数据结构来说，随机增删效率较高。检索效率较低。<br>3、链表中的元素在空间存储上，内存地址不连续。</p></blockquote><p><strong>ArrayList 集合与 LinkedList 集合：</strong></p><blockquote><p><strong>ArrayList</strong> 集合底层是数组。</p><ul><li>优点：基于数组实现，读取操作效率高。</li><li>缺点：不适合频繁进行插入和删除操作，因为每次执行该类操作都需要频繁移动其中的元素。</li></ul></blockquote><blockquote><p><strong>LinkedList</strong> 集合由双向链表实现，从任意一个节点开始，都可以很方便地访问它地前驱节点和后继节点。（双向链表的头节点和尾节点）</p><ul><li>优点：增加、删除操作只需修改链表节点指针，无需进行频繁的移动。</li><li>缺点：遍历效率较低。</li></ul></blockquote><h4 id="🍟7-3、Set"><a href="#🍟7-3、Set" class="headerlink" title="🍟7.3、Set"></a>🍟7.3、Set</h4><blockquote><p>Set 接口和 List 接口一样，都是 Collection 的子接口，Set 集合中不允许包含重复元素，没有顺序。</p></blockquote><h5 id="🍕7-3-1、HashSet-集合"><a href="#🍕7-3-1、HashSet-集合" class="headerlink" title="🍕7.3.1、HashSet 集合"></a>🍕7.3.1、HashSet 集合</h5><blockquote><p>HashSet 类是 Set 接口的典型实现，使用 HashSet 集合可以实现对无序不重复数据的存储，具有很好的存取好查找性能。</p></blockquote><p><strong>特征：</strong></p><blockquote><ul><li>不允许存储重复的元素。</li><li>没有索引，没有包含索引的方法，不能使用索引遍历。</li><li>是无序集合，存储元素和取出元素的顺序可能不一致。</li></ul></blockquote><p><strong>如下案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 HashSet 集合存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetTest</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="comment">// 1.创建一个 Set 集合和多条水果数据</span></span><br><span class="line">            <span class="type">Set</span> <span class="variable">fruits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;金帅苹果&quot;</span>,<span class="number">2.5</span>);</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;富士苹果&quot;</span>,<span class="number">2.0</span>);</span><br><span class="line">            <span class="comment">// 2.向集合中添加元素</span></span><br><span class="line">            fruits.add(fruit1);</span><br><span class="line">            fruits.add(fruit2);</span><br><span class="line">            System.out.println(<span class="string">&quot;添加重复元素，是否成功：:&quot;</span>+fruits.add(fruit1));</span><br><span class="line">            <span class="comment">// 3.遍历集合</span></span><br><span class="line">            <span class="keyword">for</span> (Object o : fruits) &#123;</span><br><span class="line">                <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> (Fruit) o;</span><br><span class="line">                fruit.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/5efd0a881c2d4b838a84ca388f568d13.png#pic_center" alt="在这里插入图片描述"></p></blockquote><p><strong>总结：</strong></p><blockquote><p>通过源码发现，实际上 HashSet 集合在 new 的时候，底层事件上 new 了一个 HashMap 集合，向 HashSet 集合中存储元素，实际上是存储到 HashMap 集合中。<br>HashMap 集合是一个哈希表数据结构<br>HashSet 集合初始化容量是 16 初始化容量建议是 2 的倍数。<br>扩容：扩容之后是原容量2倍</p></blockquote><h5 id="🍕7-3-2、TreeSet-集合类"><a href="#🍕7-3-2、TreeSet-集合类" class="headerlink" title="🍕7.3.2、TreeSet 集合类"></a>🍕7.3.2、TreeSet 集合类</h5><blockquote><p>TreeMap 集合的创建、添加、取出、遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">import</span> java.util.Comparator;</span><br><span class="line">   <span class="keyword">import</span> java.util.Iterator;</span><br><span class="line">   <span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1.1、每个集合对象的创建（new）</span></span><br><span class="line"><span class="comment">       1.2、向集合中添加元素</span></span><br><span class="line"><span class="comment">       1.3、从集合中取出某个元素</span></span><br><span class="line"><span class="comment">       1.4、遍历集合</span></span><br><span class="line"><span class="comment">       1.5、测试TreeSet集合中的元素是可排序的。</span></span><br><span class="line"><span class="comment">       1.6、测试TreeSet集合中存储的类型是自定义的。</span></span><br><span class="line"><span class="comment">       1.7、测试实现Comparable接口的方式</span></span><br><span class="line"><span class="comment">       1.8、测试实现Comparator接口的方式（最好测试以下匿名内部类的方式）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="comment">// 创建 TreeSet 集合</span></span><br><span class="line">           TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">           <span class="comment">// 向集合中添加元素</span></span><br><span class="line">           treeSet.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">           treeSet.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">           treeSet.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">           treeSet.add(<span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">           <span class="comment">// 从集合中取出元素 转为 ArrayList 集合通过下标取出</span></span><br><span class="line">           <span class="type">ArrayList</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(treeSet);</span><br><span class="line">           System.out.println(arr.get(<span class="number">0</span>));</span><br><span class="line">           System.out.println(<span class="string">&quot;===============分割线============&quot;</span>);</span><br><span class="line">           <span class="comment">// 集合遍历 获取迭代器遍历</span></span><br><span class="line">           Iterator&lt;String&gt; it = treeSet.iterator();</span><br><span class="line">           <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">               System.out.println(it.next());</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;===============分割线============&quot;</span>);</span><br><span class="line">           <span class="comment">// 遍历集合 通过增强for</span></span><br><span class="line">           <span class="keyword">for</span> (String s : treeSet) &#123;</span><br><span class="line">               System.out.println(s);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;===============分割线============&quot;</span>);</span><br><span class="line">           <span class="comment">// 测试TreeSet集合中的元素是可排序的</span></span><br><span class="line">           TreeSet&lt;Integer&gt; treeSet1 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();    <span class="comment">// 结果 1 2 3 4</span></span><br><span class="line">           treeSet1.add(<span class="number">2</span>);</span><br><span class="line">           treeSet1.add(<span class="number">4</span>);</span><br><span class="line">           treeSet1.add(<span class="number">1</span>);</span><br><span class="line">           treeSet1.add(<span class="number">3</span>);</span><br><span class="line">           <span class="keyword">for</span> (Integer integer : treeSet1) &#123;</span><br><span class="line">               System.out.println(integer);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;===============分割线============&quot;</span>);</span><br><span class="line">           <span class="comment">//测试TreeSet集合中存储的类型是自定义的</span></span><br><span class="line">          <span class="comment">/* TreeSet&lt;A&gt; treeSet2 = new TreeSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">           treeSet2.add(new A(1));</span></span><br><span class="line"><span class="comment">           treeSet2.add(new A(3));</span></span><br><span class="line"><span class="comment">           treeSet2.add(new A(2));</span></span><br><span class="line"><span class="comment">           treeSet2.add(new A(4));</span></span><br><span class="line"><span class="comment">           //遍历集合</span></span><br><span class="line"><span class="comment">           for (A a : treeSet2) &#123;</span></span><br><span class="line"><span class="comment">               System.out.println(a);</span></span><br><span class="line"><span class="comment">           &#125;*/</span></span><br><span class="line">           <span class="comment">/* 会报</span></span><br><span class="line"><span class="comment">            Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment">            java.lang.ClassCastException: Gather.GatherZoJie.A cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment">            这个异常，原因是类未实现Comparable接口</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           System.out.println(<span class="string">&quot;===============分割线============&quot;</span>);</span><br><span class="line">           <span class="comment">// 测试实现Comparable接口的方式</span></span><br><span class="line">           TreeSet&lt;B&gt; treeSet3 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">           treeSet3.add(<span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">1</span>));</span><br><span class="line">           treeSet3.add(<span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">3</span>));</span><br><span class="line">           treeSet3.add(<span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">2</span>));</span><br><span class="line">           treeSet3.add(<span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">4</span>));</span><br><span class="line">           <span class="comment">// B 类以实现 Comparable 接口,同时重写了 toString 方法</span></span><br><span class="line">           <span class="comment">// 遍历</span></span><br><span class="line">           <span class="keyword">for</span> (B b : treeSet3) &#123;</span><br><span class="line">               System.out.println(b);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 遍历结果是按 重写的compareTo方法的排序方式进行排序</span></span><br><span class="line">           System.out.println(<span class="string">&quot;===============分割线============&quot;</span>);</span><br><span class="line">           <span class="comment">//测试实现Comparator接口的方式（最好测试以下匿名内部类的方式）</span></span><br><span class="line">           <span class="comment">// 比较器方法</span></span><br><span class="line">           TreeSet&lt;C&gt; treeSet4 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;C&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(C o1, C o2)</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           treeSet4.add(<span class="keyword">new</span> <span class="title class_">C</span>(<span class="number">1</span>));</span><br><span class="line">           treeSet4.add(<span class="keyword">new</span> <span class="title class_">C</span>(<span class="number">3</span>));</span><br><span class="line">           treeSet4.add(<span class="keyword">new</span> <span class="title class_">C</span>(<span class="number">2</span>));</span><br><span class="line">           treeSet4.add(<span class="keyword">new</span> <span class="title class_">C</span>(<span class="number">4</span>));</span><br><span class="line">           <span class="comment">// 遍历</span></span><br><span class="line">           <span class="keyword">for</span> (C c : treeSet4) &#123;</span><br><span class="line">               System.out.println(c);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 输出结果 1 2 3 4 以排序</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 自定义类型A</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">       <span class="type">int</span> age;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.age = age;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 自定义类型B,实现 Comparable 接口，重写 compareTo 排序方法</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;B&gt;&#123;</span><br><span class="line">       <span class="type">int</span> age;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.age = age;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(B o)</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;B&#123;&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                   <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 自定义类型A</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">       <span class="type">int</span> age;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.age = age;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;B&#123;&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                   <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><blockquote><p>TreeSet 集合底层实际上是 TreeMap<br>new TreeSet 集合的时候，底层实际上new了一个TreeMap 集合。<br>往 TreeSet 集合中放数据的时候，实际上是将数据放到 TreeMap 集合中，<br>TreeMap 集合底层采用二叉树数据结构，能按照大小顺序排序。 </p></blockquote><p><strong>注意：</strong></p><blockquote><p>1、HashSet 底层 HashMap<br>2、TreeSet 底层 TreeMap</p></blockquote><h4 id="🍟7-4、Map"><a href="#🍟7-4、Map" class="headerlink" title="🍟7.4、Map"></a>🍟7.4、Map</h4><blockquote><p>List 集合和 Set 集合都可以存储一组数据元素，每个元素是一个对象，并且可以实现对这组数据元素的操作。</p></blockquote><p><strong>特点：</strong></p><blockquote><p>1、Map 集合和 Collection 集合没有关系。<br>2、Map 集合以 key 和 value 的这种键值对的方式存储元素。<br>3、key 和 value 都是存储 java 对象的内存地址。<br>4、所有 Map 集合的 key 特点：无序不可重复的。<br>Map 集合的 key 和 Set 集合存储元素特点相同。</p></blockquote><p><strong>Map接口方法：</strong></p><p><img src="https://img-blog.csdnimg.cn/4902ec6c794848889732605be3080a33.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>Map 接口提供了大量实现类，典型实现类如 HashMap 类、HashTable 类、TreeMap 类等。</p><h5 id="🍕7-4-1、HashMap-集合类"><a href="#🍕7-4-1、HashMap-集合类" class="headerlink" title="🍕7.4.1、HashMap 集合类"></a>🍕7.4.1、HashMap 集合类</h5><blockquote><p>HashMap 集合的创建、添加、取出、遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">   <span class="keyword">import</span> java.util.Map;</span><br><span class="line">   <span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1.1、每个集合对象的创建（new）</span></span><br><span class="line"><span class="comment">       1.2、向集合中添加元素</span></span><br><span class="line"><span class="comment">       1.3、从集合中取出某个元素</span></span><br><span class="line"><span class="comment">       1.4、遍历集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="comment">// 创建 HashMap 集合</span></span><br><span class="line">           HashMap&lt;Integer,String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">           <span class="comment">// 向集合中添加元素</span></span><br><span class="line">           hashMap.put(<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">           hashMap.put(<span class="number">2</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">           hashMap.put(<span class="number">3</span>,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">           hashMap.put(<span class="number">4</span>,<span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">           <span class="comment">// 从集合中取出某个元素</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> hashMap.get(<span class="number">1</span>);</span><br><span class="line">           System.out.println(s);</span><br><span class="line">           <span class="comment">// 遍历集合 获取所有的key，然后通过key获取value</span></span><br><span class="line">           Set&lt;Integer&gt; it = hashMap.keySet();</span><br><span class="line">           <span class="keyword">for</span> (Integer integer : it) &#123;</span><br><span class="line">               System.out.println(integer + <span class="string">&quot; =&quot;</span> + hashMap.get(integer));</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;===============分割线============&quot;</span>);</span><br><span class="line">           <span class="comment">// 遍历集合 通过 调用 entrySet方法 得到一个 Set</span></span><br><span class="line">           Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = hashMap.entrySet();</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : entries) &#123;</span><br><span class="line">               System.out.println(entry.getKey() + <span class="string">&quot; =&quot;</span> + entry.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><blockquote><p>HashMap 集合底层是哈希表数据结构<br>HashMap 集合是非线程安全的<br>在 JDK8 之后，如果哈希表单向链表中元素超过 8 个，单向链表这种数据结构会变成红黑树数据结构。当红黑树上的节点数量小于 6 时，会重新把红黑树变成单向链表数据结构。<br>这种方式也是为了提高检索效率，二叉树的检索会再次缩小扫描范围。提高效率。<br>初始化容量 .16，默认加载因子.75<br>扩容：扩容之后的容量是原容量的 2 倍。<br>HashMap 集合的 key 和 value 允许 null</p></blockquote><h4 id="🍟7-5、集合总结"><a href="#🍟7-5、集合总结" class="headerlink" title="🍟7.5、集合总结"></a>🍟7.5、集合总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、集合弥补了数组的缺陷，它比数组更灵活更实用，可大大提高软件的开发效率，而且不同的集合可用于不同场合。</span><br><span class="line">2、Java 的集合类主要由两个接口派生而出：Collection 接口和 Map 接口及相关的工具类，这两个接口又包括了一些子接口或实现类。其中，Collection 接口又包含了两个子接口—— List 接口和 Set 接口，另外一个重要接口是 Map 接口。</span><br><span class="line">    * Collection 接口存储一组不唯一，无序的对象。</span><br><span class="line">    * Set 接口继承 Collection 接口，存储一组唯一，无序的对象。</span><br><span class="line">    * List 接口继承 Collection 接口，存储一组不唯一，有序的对象</span><br><span class="line">    * Map 接口存储一组成对的 键-值对象，提供从 key 到 value 的映射。key 不要求有序，不允许重复；value 同样不要求有序，但允许重复。</span><br><span class="line">3、Iterator 为集合而生，专门实现集合的遍历。它隐藏了各种集合实现类的内部细节，提供了遍历集合的统一编程接口。</span><br><span class="line">4、ArrayList 类和数组采用相同的存储方式，它的优点在于遍历元素和随机访问元素的效率比较高。</span><br><span class="line">5、LinkedList 类采用链表存储方式，优点在于插入，删除元素时效率比较高。</span><br><span class="line">6、HashMap 类是最常见的 Map 实现类，它的存储方式是哈希表，优点是查询指定元素效率高。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5acda3e10a834f2bbd6ff010e3ad11bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><center>-----------------<b style="color:#C3C326">一份信心，一份努力，一份成功；十分信心，十分努力，十分成功。</b>-----------------------</center>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、异常</title>
      <link href="/kuailemao/1d736f48.html"/>
      <url>/kuailemao/1d736f48.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="🍖6、异常"><a href="#🍖6、异常" class="headerlink" title="🍖6、异常"></a>🍖6、异常</h3><p><strong>异常：</strong></p><blockquote><p>程序在运行过程中发生由于外部问题（如硬件错误、输入错误）等导致的程序异常事件。<br>（在Java等面向对象的编程语言中）异常本身是一个对象，产生异常就是产生了一个异常对象。</p></blockquote><h4 id="🍟6-1、异常处理机制"><a href="#🍟6-1、异常处理机制" class="headerlink" title="🍟6.1、异常处理机制"></a>🍟6.1、异常处理机制</h4><blockquote><p>在程序设计时，必须考虑到可能发生的异常事件并进行相应的处理，这样才能保证程序正常运行。</p></blockquote><h4 id="🍟6-2、异常处理结构"><a href="#🍟6-2、异常处理结构" class="headerlink" title="🍟6.2、异常处理结构"></a>🍟6.2、异常处理结构</h4><blockquote><p>java 针对异常的处理提供了 try、catch、finally、throws、throw 五个核心关键字，其中前三个关键字可以组成常用的异常处理结构。</p></blockquote><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 有可能出现异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常对象)&#123;</span><br><span class="line"><span class="comment">// 异常处理语句</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 一定会运行到的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>try 语句块用于监听，把有可能会出现异常的代码放在里面，当 try 中代码块中出现异常则会被 catch 捕捉，跳到 catch 语句块里面处理异常，finally 语句块总会被执行，finally 语句块常用于回收 try 语句块内打开的资源，如数据库连接，网络连接和磁盘文件。</p></blockquote><p><strong>常见异常处理格式：</strong></p><blockquote><p>异常格式的常见组合有 try-catch、try-catch-finally、try-finally 三种。</p></blockquote><p><strong>终止 finally 执行：</strong></p><blockquote><p>return 无法终止 finally 语句块执行，唯一能终止 finally 语句块执行的是 System.exit( 0 ) 表示停止 JVM 的执行</p></blockquote><p><strong>Exception 类型的常用方法</strong></p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void printStackTrace()</td><td align="center">输出异常堆栈信息。</td></tr><tr><td align="center">String getMessage()</td><td align="center">返回异常的详细信息。该信息描述异常产生的原因，是 printStackTrace() 方法输出信息的一部分</td></tr></tbody></table><h5 id="🍕6-2-1、多重-catch-语句"><a href="#🍕6-2-1、多重-catch-语句" class="headerlink" title="🍕6.2.1、多重 catch 语句"></a>🍕6.2.1、多重 catch 语句</h5><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 有可能出现异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常对象)&#123;</span><br><span class="line"><span class="comment">// 异常处理语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常对象)&#123;</span><br><span class="line"><span class="comment">// 异常处理语句</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 一定会运行到的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>当 try 语句块中发生异常时，系统将会按照从上到下的顺序依次检测每个 catch 语句，当匹配到某条 catch 语句后，后续其他 catch 语句块将不会被执行</li><li>以 Exception 作为参数的 catch 语句必须放在最后的位置，否则所有的异常都会被其捕获，因为 Exception 是所有能处理异常的子类的父类</li></ul></blockquote><h4 id="🍟6-3、异常继承结构图"><a href="#🍟6-3、异常继承结构图" class="headerlink" title="🍟6.3、异常继承结构图"></a>🍟6.3、异常继承结构图</h4><blockquote><p><strong>异常的继承结构图如下：</strong><br><img src="https://img-blog.csdnimg.cn/1991aae1b66c450b9f5d6ab1b10a7b93.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2l0dHlfSGFwcHk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></blockquote><p><strong>1、Error 类：</strong></p><blockquote><p>java.lang.Error 类包含仅靠程序本身无法恢复的严重错误，一般指与 JVM 相关的问题，是 java 运行环境的内部错误或硬件问题，如内存资源不足，JVM 错误等。</p></blockquote><p><strong>2、Exception 类：</strong></p><blockquote><p>java.lang.Exception 类是程序本身可以处理的异常，可分为运行时异常（Run Time Exception ）与 编译时异常（ Checked ）</p></blockquote><p><strong>2.1、运行时异常（Run Time Exception）：</strong></p><blockquote><p>可以在程序中避免的异常。这类异常在编译代码时不会被编译器检测出来，可以正常编译运行，担当程序进行时发生异常，会输出异常堆栈信息并终止程序运行，如 空指针异常、类型转换异常、数组越界异常，这些异常包括 java.long.RuntimeException 类及其子类，可以使用 try-catch 语句捕获这类异常</p></blockquote><p><strong>java 程序中常见的运行时异常：</strong></p><table><thead><tr><th align="center">异常</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ArithmeticeException</td><td align="center">出现算术错误时，抛出此异常</td></tr><tr><td align="center">ArrayIndexOutOfBoundsException</td><td align="center">当非法索引访问数组时，抛出此异常</td></tr><tr><td align="center">ClassCastException</td><td align="center">当试图将对象强制转换为非本对象类型的子类时，抛出此异常</td></tr><tr><td align="center">IllegalArgumentException</td><td align="center">当向方法传递了一个不合法或不正确的参数时，抛出此异常</td></tr><tr><td align="center">InputMismatchException</td><td align="center">当欲得到的数据类型与实际输入的类型不匹配时，抛出此异常</td></tr><tr><td align="center">NullPointerException</td><td align="center">当应用程序试图在需要对象的地方使用 null 时，抛出此异常</td></tr><tr><td align="center">NumberFormatException</td><td align="center">当试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出此异常</td></tr></tbody></table><p><strong>2.2、编译时异常（Checked）：</strong></p><blockquote><p>Checked 异常：除运行时异常外的异常，是由用户错误或问题引起的异常，这是程序员无法预见的，常见的 编译异常有 FileNotFoundException 异常、SQLException 异常等</p></blockquote><h4 id="🍟6-4、声明异常——throws-关键字"><a href="#🍟6-4、声明异常——throws-关键字" class="headerlink" title="🍟6.4、声明异常——throws 关键字"></a>🍟6.4、声明异常——throws 关键字</h4><blockquote><p>throws 关键字是方法可能抛出异常的声明，使用 throws 关键字在方法上声明异常，声明异常之后，异常由上一级（调用者）处理</p></blockquote><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名() <span class="keyword">throws</span> 异常类型[,异常类型]&#123; <span class="comment">// 声明的异常类型可多个</span></span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不建议在 main() 方法继续声明异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main( ) 方法中声明异常由 JVM 处理，如果程序出现了错误，会导致程序中断执行。</p></blockquote><h4 id="🍟6-5、抛出异常——throw-关键字"><a href="#🍟6-5、抛出异常——throw-关键字" class="headerlink" title="🍟6.5、抛出异常——throw 关键字"></a>🍟6.5、抛出异常——throw 关键字</h4><blockquote><p>可以使用 throw 关键字手动抛出异常，使用 new 关键字创建异常类的对象，通过 throw 关键字抛出。</p></blockquote><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常名( [ 参数列表 ] );</span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>使用 throw 关键字抛出的只能是 Throwable 类或其子类的对象</p></blockquote><h4 id="🍟6-6、自定义异常"><a href="#🍟6-6、自定义异常" class="headerlink" title="🍟6.6、自定义异常"></a>🍟6.6、自定义异常</h4><blockquote><p>当 java 异常体系中提供的异常类型不能满足程序的需要时，可以自定义异常类，使用自定义异常一般有如下三个步骤：<br>（1）定义 异常类，继承 Exception 类或 RuntimeException 类。<br>（2）编写异常类的构造方法，并继承父类的实现。<br>（3）实例化自定义异常对象，并使用 throw 关键字抛出。</p></blockquote><p><strong>如下自定义异常：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年龄异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message, cause);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面自定义异常的 Test 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowTest</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.print(<span class="string">&quot;请录入您的年龄：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">ThrowTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThrowTest</span>();</span><br><span class="line">                System.out.println(test.ShowTicketPrice(age));</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">                System.out.println( ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据年龄显示票价信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String <span class="title function_">ShowTicketPrice</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            <span class="keyword">if</span>(age &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;您录入的年龄有误，3岁以下儿童暂不能观影！&quot;</span>); <span class="comment">// 抛出自定义异常</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age &gt;= <span class="number">60</span> || age &lt;= <span class="number">6</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;您可以购买半价票 25 元！&quot;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;您需要购买全票价 50 元！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="🍟6-7、异常总结"><a href="#🍟6-7、异常总结" class="headerlink" title="🍟6.7、异常总结"></a>🍟6.7、异常总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、异常是由 java 应用程序抛出和处理的非严重错误，它可以分为运行时异常和 Checked 异常两大类。</span><br><span class="line">2、Checked 异常必须捕获或声明抛出，否则无法通过编译。运行时异常不要求必须捕获或声明抛出。</span><br><span class="line">3、java 异常处理是通过五个关键字实现的：try、catch、finally、throw、throws。功能如下：</span><br><span class="line">       * try：用户监听。将可能抛出异常的代码放在 try 语句块之内，当 try 语句块内发生异常时，会跳到 catch 语句块内执行。</span><br><span class="line">       * catch：用户捕获异常。catch 语句用来捕获 try 语句块中发生的异常。</span><br><span class="line">       * finally：finally 语句块总是会被执行。它主要用于回收在 try 语句块里打开的资源（如数据库连接）</span><br><span class="line">       * throw：用于抛出异常</span><br><span class="line">       * throws：用于声明方法中可能抛出的异常。在该方法中可以不强制进行异常处理，如果出现了异常，则交给（上层）调用者进行处理。</span><br><span class="line">4、可以在一个 try 块后跟随多个 catch 块，分别处理不同的异常，但排列顺序必须是从特殊到一般，最后一个一般为 Exception 类。</span><br></pre></td></tr></table></figure><center>-----------------------<b style="color:#C3C326">人生最大的喜悦是每个人都说你做不到，而你却完成它了！</b>-----------------------</center>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、抽象类和接口</title>
      <link href="/kuailemao/b19125d3.html"/>
      <url>/kuailemao/b19125d3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="🍖5、抽象类和接口"><a href="#🍖5、抽象类和接口" class="headerlink" title="🍖5、抽象类和接口"></a>🍖5、抽象类和接口</h3><h4 id="🍟5-1、抽象类"><a href="#🍟5-1、抽象类" class="headerlink" title="🍟5.1、抽象类"></a>🍟5.1、抽象类</h4><blockquote><p>顾名思义，抽象类就是抽象出来的类，一般来说，具体类有直接对应的对象，而抽象类没有，它往往表达的是抽象的概念。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>一只猫是具体对象，而猫科动物则是抽象的概念；玉米是具体对象，而作物则是抽象概念。</p></blockquote><p><strong>语法：</strong></p><blockquote><p>&lt; 访问修饰符 &gt; abstract class &lt; 类名 &gt;{ }</p></blockquote><blockquote><p>abstract 关键字表示该类被定义为抽象类</p></blockquote><p><strong>区别：</strong></p><blockquote><p>抽象类与普通类的最大区别就是：普通类可以被实例化，而抽象类不能被实例化</p></blockquote><h4 id="🍟5-2、抽象方法"><a href="#🍟5-2、抽象方法" class="headerlink" title="🍟5.2、抽象方法"></a>🍟5.2、抽象方法</h4><blockquote><p>当一个类的方法被 abstract 关键字修饰时，该方法被称为抽象方法。</p></blockquote><p><strong>注意：</strong></p><blockquote><p>抽象方法所在的类必须是抽象类，抽象类中可以包含抽象方法，也可以包含普通方法，还可以包含普通类包含的一切成员。</p></blockquote><p><strong>抽象方法：</strong></p><blockquote><p>一个方法被定义为抽象方法，意味着该方法不会有具体的实现（没有方法体），而在抽象类的子类中通过方法重写实现。</p></blockquote><p><strong>语法：</strong></p><blockquote><p>[ 访问修饰符 ] abstract &lt;返回类型&gt; &lt; 方法名 &gt;  ( [ 参数列表 ] )<br>abstract 关键字表示该方法被定义为抽象方法</p></blockquote><p><strong>区别：</strong></p><blockquote><p>抽象方法与普通方法最大的区别是：普通方法有方法体，而抽象方法没有方法体。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123; &#125; <span class="comment">// 普通方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><blockquote><p>1、在抽象类中，可以没有、有一个或多个抽象方法，甚至可以定义全部方法都是抽象方法。<br>2、抽象方法只有方法声明，没有方法实现。有抽象方法的类必须声明为抽象类。子类必须重写所有的抽象方法才能实例化；否则子类也必须声明成抽象类<br>3、抽象类可以有构造方法，其构造方法可以被本类的其他构造方法调用。若此构造方法不是由 private 修饰的，也可以被本类的子类中的构造方法调用。</p></blockquote><h4 id="🍟5-3、final-修饰符"><a href="#🍟5-3、final-修饰符" class="headerlink" title="🍟5.3、final 修饰符"></a>🍟5.3、final 修饰符</h4><blockquote><p>final 是 java 关键字，表示 ”最后的、最终的、不可变的 “。</p></blockquote><p><strong>1、final 修饰的类：</strong></p><blockquote><p>用 final 修饰的类不能再被继承，没有子类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Puppy</span> <span class="keyword">extends</span> <span class="title class_">Dog</span>&#123;<span class="comment">// 不能被继承</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、final 修饰类的方法</strong></p><blockquote><p>用 final 修饰的类的方法不能被子类重写</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;<span class="comment">// 不能被子类重写</span></span><br><span class="line">System.out.println(<span class="string">&quot;记得快乐！&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、final 修饰的变量</strong></p><blockquote><p>final 修饰的变量叫做常量，如定义成员变量，一定需要初始化，不然报错，如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><blockquote><p>final 修饰的局部变量只能赋值一次，不然报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> i;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line">i = <span class="number">11</span>;<span class="comment">// 会报错，只能赋值一次</span></span><br></pre></td></tr></table></figure><h4 id="🍟5-3、final-与-abstract-修饰符"><a href="#🍟5-3、final-与-abstract-修饰符" class="headerlink" title="🍟5.3、final 与 abstract 修饰符"></a>🍟5.3、final 与 abstract 修饰符</h4><p><strong>abstract：</strong></p><blockquote><p>可以用来修饰类和方法，不能用来修饰属性和构造方法。</p></blockquote><p><strong>final：</strong></p><blockquote><p>final 可以用来修饰类，方法和属性，不能修饰构造方法</p></blockquote><h4 id="🍟5-4、接口"><a href="#🍟5-4、接口" class="headerlink" title="🍟5.4、接口"></a>🍟5.4、接口</h4><blockquote><p>接口类似一套规范，定义统一的标准，可以约束类的行为，使实现接口的类（或结构）在形式上保持一致</p></blockquote><h5 id="🍕5-4-1、定义和实现接口"><a href="#🍕5-4-1、定义和实现接口" class="headerlink" title="🍕5.4.1、定义和实现接口"></a>🍕5.4.1、定义和实现接口</h5><p><strong>接口定义：</strong></p><blockquote><p>接口类型的定义语法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] interface 接口名 &#123;</span><br><span class="line"><span class="comment">// 接口成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口实现：</strong></p><blockquote><p>类实现接口的语法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口名&#123;</span><br><span class="line"><span class="comment">// 类成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中的属性都会自动加上 public static final 修饰，无论是否写了此关键字，接口的属性都是全局静态常量，必须在定义时指定初始值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">P</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// ①</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">P</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 效果与 ① 的效果一致</span></span><br><span class="line"><span class="type">int</span> P;<span class="comment">// 没有初始化会报错</span></span><br></pre></td></tr></table></figure><p><strong>接口方法：</strong></p><blockquote><p>在接口中可以定义 抽象方法、默认方法、静态方法，如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span>; <span class="comment">// 抽象方法没有方法体，非抽象子类必须重写</span></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">function2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>如下实现类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span> &#123; <span class="comment">// 重写抽象方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;实现 MyInterface 接口的 function1()!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        myClass.function1();    <span class="comment">//调用实现类中重写的方法</span></span><br><span class="line">        myClass.function2();    <span class="comment">// 调用接口中的默认方法</span></span><br><span class="line">        MyInterface.function3();    <span class="comment">// 调用接口中的静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/56c4bd572851454083d0512e9dc3abaa.png#pic_center" alt="在这里插入图片描述"></p></blockquote><p><strong>接口本身继承接口：</strong></p><blockquote><p>接口本身也可以继承接口，如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ 访问修饰符 ] interface 接口名 extends 父接口<span class="number">1</span>、父接口<span class="number">2</span>、…&#123;</span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="comment">// 方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现多个接口：</strong></p><blockquote><p>一个普通类只能继承一个父类，但能同时实现多个接口，也可以同时继承一个父类并实现多个接口。如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 extends 父类名 implements 接口<span class="number">1</span>、接口<span class="number">2</span>…&#123;</span><br><span class="line"><span class="comment">// 类的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>普通类不管同时实现多少接口，必须把接口中的所有抽象方法全部重写。</p></blockquote><h4 id="🍟5-5、面向对象设计原则"><a href="#🍟5-5、面向对象设计原则" class="headerlink" title="🍟5.5、面向对象设计原则"></a>🍟5.5、面向对象设计原则</h4><blockquote><p>在实际开发过程中，遵循以下原则会让代码更具有灵活性，更能适应变化。</p><ul><li><p>1、摘取代码中变化的部分，形成接口</p></li><li><p>2、多用组合，少用继承</p></li><li><p>3、面向接口编程，不依赖于具体实现</p></li><li><p>4、针对扩展开放，针对改变关闭（开闭原则）</p><p>–5、面向接口编程，不依赖于具体实现–</p></li></ul></blockquote><p><strong>总结：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 抽象类使用 abstract 修饰，不能实例化</span><br><span class="line">* 抽象类中可以用零个到多个抽象方法。抽象方法使用 abstract 关键字修饰，没有方法体。</span><br><span class="line">* 如果非抽象类继承抽象类，则必须实现（重写）父类的所有抽象方法，否则子类只能是一个抽象类</span><br><span class="line">* 用 final 关键字修饰的类，不能再被继承。用 final 修饰的方法，不能被子类重写。用 final 关键字修饰的变量将变成常量，只能在初始化时进行赋值，不能在其他地方修改。</span><br><span class="line">* 接口中的属性都是全局静态常量。自 JDK 1.8 起，在接口中可以定义的方法包括抽象方法，静态方法和默认方法</span><br><span class="line">* 类只能继承一个父类，但是可以实现多个接口。java 通过实现接口可以达到多重继承的效果。</span><br><span class="line">* 接口表示一种约定，也表示一种能力。接口体现了约定和实现相分离的原则。通过面向接口编程，可以降低代码间的耦合性，提高代码的可扩展性和可维护性。</span><br></pre></td></tr></table></figure><center>-----------------------<b style="color:#C3C326">拥有梦想只是一种智力，实现梦想才是一种能力。</b>-----------------------</center>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、三大特性总结</title>
      <link href="/kuailemao/cb058ce6.html"/>
      <url>/kuailemao/cb058ce6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="🍖4、三大特性总结"><a href="#🍖4、三大特性总结" class="headerlink" title="🍖4、三大特性总结"></a>🍖4、三大特性总结</h3><p><strong>面向对象的三大特性：封装、继承、多态。</strong></p><blockquote><ul><li>封装就是声明类的成员变量为私有的，同时提供公有的方法实现对该成员变量的存取操作。</li><li>继承是软件可重用性的一种表现，新类可以在不增加自身代码的情况下，通过从现有的类中继承其属性和方法充实自身内容，这种现象或行为被称为继承。</li><li>多态是具有表现多种形态的能力的特征。在程序设计的术语中，它意味着一个特定类型的变量可以引用不同类型的对象，并且能自动地调用引用地对象的方法，也就是根据作用到的不同的对象类型，响应不同的操作。</li></ul></blockquote><center>-----------------------<b style="color:#C3C326">滴水穿石，不是力量大，而是功夫深。</b>-----------------------</center><p><strong>封装、继承、多态三大特性在Java中非常非常非常重要，一定要统统理解</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、多态</title>
      <link href="/kuailemao/ac7faf0f.html"/>
      <url>/kuailemao/ac7faf0f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="🍖3、多态"><a href="#🍖3、多态" class="headerlink" title="🍖3、多态"></a>🍖3、多态</h3><blockquote><ul><li><p>面向对象的三大特性为 封装、继承、多态。最后一个特性——多态。它能使同一个操作当作用于不同的对象时，产生不同的执行结果。</p></li><li><p>使用多态可以提高代码的可维护性和可扩展性</p></li></ul></blockquote><h4 id="🍟3-1、子类到父类的转换（向上转型）"><a href="#🍟3-1、子类到父类的转换（向上转型）" class="headerlink" title="🍟3.1、子类到父类的转换（向上转型）"></a>🍟3.1、子类到父类的转换（向上转型）</h4><blockquote><p>子类到父类的转换被称为向上转型。（自动类型转换）</p></blockquote><p> <strong>语法：</strong></p><blockquote><p>&lt; 父类型 &gt; &lt; 引用变量名 &gt; &#x3D; new &lt; 子类型 &gt; ( );</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Strive</span> <span class="variable">strive1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">s1</span>();</span><br></pre></td></tr></table></figure><p>Strive 为父类型 strive1 为引用变量名 s1 为子类型</p><ul><li>父类型的引用指向子类型的对象</li></ul><p><strong>实现多态的三个条件如下：</strong></p><blockquote><p>1、继承的存在（继承是多态的继承，没有继承就没有多态）。</p><blockquote><p>2、子类重写父类的方法（多态下调用子类重写后的方法）。</p><blockquote><p>3、父类引用变量指向子类对象（向上转型）。</p></blockquote></blockquote></blockquote><h4 id="🍟3-2、父类到子类的转换（向下转型）"><a href="#🍟3-2、父类到子类的转换（向下转型）" class="headerlink" title="🍟3.2、父类到子类的转换（向下转型）"></a>🍟3.2、父类到子类的转换（向下转型）</h4><blockquote><p>父类到子类的转换被称为向上转型。（强制类型转换）</p></blockquote><p><strong>语法：</strong></p><blockquote><p>&lt; 子类型 &gt; &lt; 引用变量名 &gt; &#x3D; ( &lt; 子类型 &gt; ) &lt; 父类型的引用变量 &gt;;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Strive</span> <span class="variable">strive1</span> <span class="operator">=</span> (Strive)s1;</span><br></pre></td></tr></table></figure><p>s1 为 父类型的引用变量，Strive 为子类型，strive1 为引用变量名</p><h4 id="🍟3-3、instanceof-运算符"><a href="#🍟3-3、instanceof-运算符" class="headerlink" title="🍟3.3、instanceof 运算符"></a>🍟3.3、instanceof 运算符</h4><p><strong>语法：</strong></p><blockquote><p>对象 instanceof 类或接口</p></blockquote><ul><li>该运算符用来判断一个对象是否属于一个类或实现了一个接口，结果为 <strong>true</strong> 或 <strong>false</strong>。</li><li>在强制类型转换之前通过 <strong>instanceof</strong> 运算符检查对象的真实类型，再进行相应的强制类型转换，这样就可以避免类型转换异常，从而提高代码的健壮性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Strive <span class="keyword">instanceof</span> s1)&#123;  <span class="comment">// 类型判断</span></span><br><span class="line">          <span class="type">Strive</span> <span class="variable">strive1</span> <span class="operator">=</span> (Strive)s1;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Strive与s1没有关系&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="🍟3-4、多态的优势"><a href="#🍟3-4、多态的优势" class="headerlink" title="🍟3.4、多态的优势"></a>🍟3.4、多态的优势</h4><ul><li>可替换性：多态对已存在的代码具有可替换性</li><li>可扩充性：多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性，继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。</li><li>灵活性：在多态的应用中，体现了灵活多样的操作，提高了使用效率。</li><li>简化性：多态简化了应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出</li></ul><p><strong>多态的使用大多体现在实际开发中，多写代码，多用多态，慢慢自然能够体验到多态的灵活性以及多态的重要性</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、继承</title>
      <link href="/kuailemao/afa0fa4c.html"/>
      <url>/kuailemao/afa0fa4c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="🍖2、继承"><a href="#🍖2、继承" class="headerlink" title="🍖2、继承"></a>🍖2、继承</h3><h4 id="🍟2-1、继承的基本概念"><a href="#🍟2-1、继承的基本概念" class="headerlink" title="🍟2.1、继承的基本概念"></a>🍟2.1、继承的基本概念</h4><blockquote><p>继承是面向对象的三大特征之一，继承可以解决编程中代码冗余的问题，是实现代码重用的重要手段之一。<br><strong>语法：</strong><br>[ 访问修饰符 ] class  &lt;SubClass&gt;  extends &lt;SuperClass&gt;{</p><p>}</p></blockquote><p>其中，SubClass 被称为子类或派生类，SuperClass 被称为父类或基类。</p><blockquote><p>Java 继承规则如下：<br>1、可以继承父类中 public 和 protected 修饰的属性和方法，不论子类和父类是否在同一包中。<br>2、可以继承默认访问修饰符修饰的属性和方法，但是子类和父类必须在同一包中<br>3、无法继承 private 修饰的属性和方法<br>4、无法继承父类的构造方法</p></blockquote><p><strong>注意：</strong></p><blockquote><p>在 Java 中只支持单继承，即每个类只能有一个直接父类</p></blockquote><h4 id="🍟2-2、继承的应用"><a href="#🍟2-2、继承的应用" class="headerlink" title="🍟2.2、继承的应用"></a>🍟2.2、继承的应用</h4><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *动物父类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物叫。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*继承了动物类的小猫类也有 cry() 方法（子类）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="comment">// 有父类的方法与属性 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🍟2-3、Object"><a href="#🍟2-3、Object" class="headerlink" title="🍟2.3、Object"></a>🍟2.3、Object</h4><blockquote><p>Object 类属性超级父类（老祖宗），当一个类没有任何继承的时候，默认继承 Object 类，自带 Object 类里面的 方法与属性</p></blockquote><p><strong>注意：</strong></p><blockquote><p>子类被创建对象的时候必是先执行 Object 类的构造方法，因为构造方法第一行中有隐藏的 super() 调用父类构造方法，最终的父类一定是 Object 类</p></blockquote><h4 id="🍟2-4、继承关系中的方法重写"><a href="#🍟2-4、继承关系中的方法重写" class="headerlink" title="🍟2.4、继承关系中的方法重写"></a>🍟2.4、继承关系中的方法重写</h4><blockquote><p>子类通过继承可以拥有和父类相同的特征和行为，另外，子类也可以定义自己特有的行为，既沿袭了父类的方法名称，又重新实现了父类方法，这就是方法重写。</p></blockquote><blockquote><p>在子类中可以根据需求对从父类继承的方法进行重写编写，这被称为方法重写或方法覆盖。</p></blockquote><p><strong>方法重写必须遵守以下规则：</strong></p><ul><li>重写方法和被重写方法必须具有相同的方法名</li><li>重写方法和被重写方法必须具有相同的参数列表</li><li>重写方法的返回值类型必须和被重写方法的返回值类型相同或是其子类</li><li>重写方法不能缩小被重写方法的访问权限</li></ul><p><strong>重写的时候可以在方法上面使用注解：</strong></p><blockquote><p>@Override<br>@Override 是用 Java 注解的方法表示该方法重写了父类方法，可以写也可以不写，在功能实现上没有区别，但是通过 @Override 注解，程序更加方便阅读。另外，编译器也会帮助验证 @Override 下面的方法名是否是父类所有的。如果其不符合方法重写规则，则会报错。</p></blockquote><p><strong>提示：</strong></p><blockquote><p>Java 注解又被称为 Java 标注，是 Java 5 引入的一种注解机制。  </p></blockquote><h4 id="🍟2-5、方法重载和方法重写的区别"><a href="#🍟2-5、方法重载和方法重写的区别" class="headerlink" title="🍟2.5、方法重载和方法重写的区别"></a>🍟2.5、方法重载和方法重写的区别</h4><ul><li>方法重载涉及同一个类中的同名方法，要求方法名相同，参数列表不同，与返回值类型和访问修饰符无关</li><li>方法重写涉及的是子类和父类之间的同名方法，要求方法名相同，参数列表相同，返回值类型i相同或是其子类</li></ul><h4 id="🍟2-6、super关键字"><a href="#🍟2-6、super关键字" class="headerlink" title="🍟2.6、super关键字"></a>🍟2.6、super关键字</h4><blockquote><p>如果想在子类中调用父类的被重写的方法，可以使用 ” super.方法名 “实现</p></blockquote><p>super 关键字代表对当前对象的直接父类对象的默认引用。在子类中可以通过 super 关键字访问父类的成员，包括父类的属性和方法。语法如下：</p><blockquote><p>语法：<br>访问父类构造方法 ：super(参数)<br>访问父类属性 &#x2F; 方法 ：super.&lt; 父类属性 &#x2F; 方法 &gt;</p></blockquote><p>使用 super 关键字，需要注意以下几点：</p><ul><li>super 关键字必须出现在子类（子类的方法和构造方法）中，而不允许在其他位置。</li><li>可以访问父类的成员，如父类的属性，方法，构造方法。</li><li>注意访问权限的限制，如无法通过 super 关键字访问 private 成员。</li></ul><p><strong>注意：</strong></p><blockquote><p>1、在构造方法中如果有 this 语句或 super 语句，则只能是第一条语句。<br>2、在一个构造方法中，不允许同时使用 this 关键字和 super 关键字调用构造方法（否则就有两条第一条语句）。<br>3、在静态方法中不允许出现 this 关键字或 super 关键字。<br>4、在实例方法中，this 语句和 super 语句不要求是第一条语句，可以共存。<br>5、子类构造方法中第一行有隐藏的 <strong>super( )</strong> 调用父类构造方法，最终父类一定是 Object 类</p></blockquote><h4 id="🍟2-7、继承关系中的构造方法"><a href="#🍟2-7、继承关系中的构造方法" class="headerlink" title="🍟2.7、继承关系中的构造方法"></a>🍟2.7、继承关系中的构造方法</h4><p>在 Java 中，一个类的构造方法在如下两种情况下会被执行：</p><ul><li>创建该类对象（实例化）</li><li>创建该类的子类对象（子类的实例化）</li></ul><blockquote><p>子类在实例化时，会首先执行其父类的构造方法，然后才会执行子类的构造方法。<br>在 Java 语言中，当创建一个对象时，Java 虚拟机（JVM）会按照父类——&gt;子类的顺序执行一系列的构造方法。</p></blockquote><p><strong>子类继承父类时构造方法的调用规则如下：</strong></p><ul><li>如果在类的构造方法中没有通过 super 关键字显式调用父类地带参构造方法，也没有通过 this 关键字显式调用自身地其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，是否写 “ super( );  ”语句，效果是一样的。</li><li>如果在子类的构造方法中通过 super 关键字显式地调用了父类地带参构造方法，那么将执行父类相应的构造方法，而不执行父类无参构造方法。</li><li>如果在子类的构造方法中通过 this 关键字显式地调用了自身地其他构造方法，那么在相应构造方法中遵循以上两条规则。</li><li>如果存在多级继承关系，则在创建一个子类对象时，以上规则会多次向上更高一级父类应用，直到执行顶级父类 Object 类的无参构造方法为止。</li></ul><center>-----------------------<b style="color:#C3C326">世界会向那些有目标和远见的人让路。</b>-----------------------</center>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、对象和封装</title>
      <link href="/kuailemao/742759.html"/>
      <url>/kuailemao/742759.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="3-28"><a href="#3-28" class="headerlink" title="3:28"></a>3:28</h2><h3 id="🍖1、对象和封装"><a href="#🍖1、对象和封装" class="headerlink" title="🍖1、对象和封装"></a>🍖1、对象和封装</h3><h4 id="🍟1-1、构造方法"><a href="#🍟1-1、构造方法" class="headerlink" title="🍟1.1、构造方法"></a>🍟1.1、构造方法</h4><p><strong>语法：</strong></p><blockquote><p>[ 访问修饰符 ]  方法名   ( [  参数列表  ] ){<br>    &#x2F;&#x2F;……省略方法体的代码<br>}</p></blockquote><ul><li><p>构造方法的名称必须和类名相同，但是没有返回值类型。在构造方法的定义中参数列表是可选的，因此可以定义无参构造方法，也可以定义带参构造方法。</p></li><li><p>在java中，每一个类都默认自带了一个构造方法叫做<strong>缺省构造器</strong>，如有没有创建，则系统会自动创建一个默认的构造方法，默认构造方法是没有参数的，而且在方法体中没有代码。（无参构造器）</p></li></ul><p> <strong>注意：</strong> 当我们创建了构造方法之后，Java自带的无参构造方法就会消失，需要我们自己写出来</p><h4 id="🍟1-2、this"><a href="#🍟1-2、this" class="headerlink" title="🍟1.2、this"></a>🍟1.2、this</h4><p><strong>this 的三种用法：</strong></p><blockquote><p>1、使用 <strong>this</strong> 关键字调用成员变量，解决成员变量和局部变量的同名冲突</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Strive</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;  <span class="comment">//成员变量和局部变量同名，必须使用 this 关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、使用 <strong>this</strong> 关键字调用成员方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Strive</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.print(); <span class="comment">// 调用成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.使用 <strong>this</strong> 关键字调用已定义的构造方法<br>在以下代码中定义了 Strive 类，并定义了两个带参构造方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Strive</span><span class="params">()</span>&#123;</span><br><span class="line">       String name;</span><br><span class="line">       String sex;</span><br><span class="line">       <span class="type">int</span> age;</span><br><span class="line">       String dept;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Strive</span><span class="params">(String name, String sex)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.name = name;</span><br><span class="line">           <span class="built_in">this</span>.sex = sex;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Strive</span><span class="params">(String name, String sex, <span class="type">int</span> age, String dept)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>(name,sex);<span class="comment">//调用已定义的构造方法（调用上面那个构造方法）</span></span><br><span class="line">           <span class="built_in">this</span>.age = age;</span><br><span class="line">           <span class="built_in">this</span>.dept = dept;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上使用 <strong>this</strong> 关键字调用构造方法，并传入局部变量 name 和 sex 作为参数，执行时，首先执行 Strive(String name,String sex) 构造方法，完成对 name 属性和 sex 属性的赋值，然后执行后面的语句实现对 age 属性和 dept 属性的赋值。</p><h4 id="🍟1-3、方法重载"><a href="#🍟1-3、方法重载" class="headerlink" title="🍟1.3、方法重载"></a>🍟1.3、方法重载</h4><h5 id="🍕1-3-1、方法重载的定义"><a href="#🍕1-3-1、方法重载的定义" class="headerlink" title="🍕1.3.1、方法重载的定义"></a>🍕1.3.1、方法重载的定义</h5><blockquote><p>方法重载指的是同一个类包含两个或两个以上的方法，它们的方法名相同，方法参数个数不同，<br>方法参数类型不同。成员方法和构造方法都可以进行重载</p></blockquote><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">System.out.println(<span class="literal">true</span>);</span><br><span class="line">System.out.println(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这里的方法重载使用的是方法参数类型不同</p><h5 id="🍕1-3-2、方法重载的特点"><a href="#🍕1-3-2、方法重载的特点" class="headerlink" title="🍕1.3.2、方法重载的特点"></a>🍕1.3.2、方法重载的特点</h5><p>方法重载判断的依据如下：</p><ul><li>必须在同一个类中</li><li>方法名相同</li><li>参数列表 （方法参数的个数或参数类型） 不同</li></ul><p><strong>注意：</strong> 方法的返回值和方法的访问修饰符不能作为判断方法之间是否构成重载的依据</p><h5 id="🍕1-3-3、方法重载的使用和优点"><a href="#🍕1-3-3、方法重载的使用和优点" class="headerlink" title="🍕1.3.3、方法重载的使用和优点"></a>🍕1.3.3、方法重载的使用和优点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Strive</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a+b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Strive</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a+b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">Strive</span><span class="params">(String s1,String s2)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> s1+s2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Adder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adder</span>();</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">6</span>,b = <span class="number">8</span>;</span><br><span class="line">      System.out.println(adder.Strive(a,b));</span><br><span class="line">      <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">9</span> , d = <span class="number">10.9</span>;</span><br><span class="line">      System.out.println(adder.Strive(c,d));</span><br><span class="line">      <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>,s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">      System.out.println(adder.Strive(s1,s2));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>由以上代码可见，方法重载是对原有方法的一种升级，可以根据参数的不同，采用不同的实现方法，而且不需要编写多个名称，简化了类调用方法的代码</li></ul><h4 id="🍟1-4、使用封装重构类的属性和方法"><a href="#🍟1-4、使用封装重构类的属性和方法" class="headerlink" title="🍟1.4、使用封装重构类的属性和方法"></a>🍟1.4、使用封装重构类的属性和方法</h4><h5 id="🍕1-3-1、封装的概念"><a href="#🍕1-3-1、封装的概念" class="headerlink" title="🍕1.3.1、封装的概念"></a>🍕1.3.1、封装的概念</h5><blockquote><p>封装是面向对象的三大特性之一，就算将类的状态信息隐藏在类内部，不允许外部程序直接访问，而通过该类提供的方法实现对隐藏信息的操作和访问。</p></blockquote><blockquote><p>封装反映了事物的相对独立性，有效避免了外部错误对此对象的影响，并且能够给用户由于大意产生的错误操作起到预防作用</p></blockquote><ul><li><strong>好处：</strong> 封装的好处在于隐藏类的细节，让用户只能通过开发人员规定的方法访问数据，可以方便地加入访问修饰符来限制不合理操作</li></ul><h5 id="🍕1-4-2、封装的步骤"><a href="#🍕1-4-2、封装的步骤" class="headerlink" title="🍕1.4.2、封装的步骤"></a>🍕1.4.2、封装的步骤</h5><p>实现封装的步骤如下：</p><blockquote><p>1、修改属性的可见性来限制对属性的访问<br>2、 为每个属性创建一对赋值（setter）方法和取值（getter）方法，用户对这些属性的存取<br>3、在赋值方法中，可以加入对属性的存取控制语句</p></blockquote><h6 id="🧀1、修改属性的可见性："><a href="#🧀1、修改属性的可见性：" class="headerlink" title="🧀1、修改属性的可见性："></a>🧀1、修改属性的可见性：</h6><blockquote><p>使用 private 访问修饰符修饰，private 修饰的属性和方法只能在定义它的类的内部被访问</p></blockquote><h6 id="🧀2、创建赋值和取值方法："><a href="#🧀2、创建赋值和取值方法：" class="headerlink" title="🧀2、创建赋值和取值方法："></a>🧀2、创建赋值和取值方法：</h6><blockquote><p>get 方法取值、 set 方法存值<br>get 方法读、 set 方法改<br>以上看哪一个能理解，意思一致，代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;  <span class="comment">// 私有属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span>&#123; <span class="comment">//get方法 读</span></span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123; <span class="comment">//set 改</span></span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="🧀3、加入对属性的存取控制语句"><a href="#🧀3、加入对属性的存取控制语句" class="headerlink" title="🧀3、加入对属性的存取控制语句"></a>🧀3、加入对属性的存取控制语句</h6><blockquote><p>为了限制不合理赋值，除了设置属性的私有性，还可以在赋值方法中加入对属性的存取控制语句。<br>假如性别：只有男，女，年龄：0~100 ;代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> grnder; <span class="comment">// 性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"><span class="comment">// 省略get 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;<span class="comment">//控制年龄</span></span><br><span class="line"> <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;输入的年龄为:&quot;</span>+age+<span class="string">&quot;,该年龄不合法！&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.age = age;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;<span class="comment">//控制性别</span></span><br><span class="line">       <span class="keyword">if</span>(gender.equals(<span class="string">&quot;男&quot;</span>) || gender.equals(<span class="string">&quot;女&quot;</span>))&#123;</span><br><span class="line">           <span class="built_in">this</span>.gender = gender;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;*** 性别不合法 ！***&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="🍟1-5、类和类成员的访问控制"><a href="#🍟1-5、类和类成员的访问控制" class="headerlink" title="🍟1.5、类和类成员的访问控制"></a>🍟1.5、类和类成员的访问控制</h4><p>1、类和访问修饰符</p><table><thead><tr><th>修饰符</th><th>同一包中</th><th>非同一包中</th></tr></thead><tbody><tr><td>public</td><td>可以使用</td><td>可以使用</td></tr><tr><td>默认修饰符</td><td>可以使用</td><td>不可以使用</td></tr></tbody></table><blockquote><p>省略访问修饰符，就算默认修饰符</p></blockquote><p>2、类成员的访问修饰符</p><table><thead><tr><th>修饰符</th><th>同一类中</th><th>同一包中</th><th>子类中</th><th>外部包</th></tr></thead><tbody><tr><td>private</td><td>可以使用</td><td>不可以使用</td><td>不可以使用</td><td>不可以使用</td></tr><tr><td>默认修饰符</td><td>可以使用</td><td>可以使用</td><td>不可以使用</td><td>不可以使用</td></tr><tr><td>protected</td><td>可以使用</td><td>可以使用</td><td>可以使用</td><td>不可以使用</td></tr><tr><td>public</td><td>可以使用</td><td>可以使用</td><td>可以使用</td><td>可以使用</td></tr></tbody></table><h4 id="🍟1-6、static-关键字"><a href="#🍟1-6、static-关键字" class="headerlink" title="🍟1.6、static 关键字"></a>🍟1.6、static 关键字</h4><blockquote><p>static 关键字可以修饰类的属性，方法和代码块。使用 static 修饰的属性和方法不再属于具体的某个对象，而属性它所在的类</p></blockquote><blockquote><p>使用 static 修饰的 属性或方法可以使用 “ 类名 . ” 的方式调用，不需要再消耗资源反复创建对象</p></blockquote><blockquote><p>使用 static 修饰的方法属于 静态方法，使用类名调用，static 修饰的变量属于静态变量，类加载的时候加载进方法区</p></blockquote><h5 id="🍕1-6-1、用-static-关键字修饰属性和代码块"><a href="#🍕1-6-1、用-static-关键字修饰属性和代码块" class="headerlink" title="🍕1.6.1、用 static 关键字修饰属性和代码块"></a>🍕1.6.1、用 static 关键字修饰属性和代码块</h5><p>如下静态代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>static 修饰的是类加载的时候执行，创建对象的时候执行，创建对象的时候应先执行 static静态代码块里面的内容</p></blockquote><p><strong>注意：</strong></p><ul><li>有多个静态代码块的时候，按照静态代码块的前后顺序执行</li><li>在方法里不可以定义 static 变量，也就是静态变量不能是局部变量</li><li>在静态方法中不能直接访问实例变量和实例方法</li><li>在实例方法中可以直接调用类中定义的静态变量和静态方法</li></ul><center>-----------------------<b style="color:#C3C326">生命不是要超越别人，而是要超越自己。</b>-----------------------</center>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Javase基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/kuailemao/20244.html"/>
      <url>/kuailemao/20244.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、JavaScript基础"><a href="#1、JavaScript基础" class="headerlink" title="1、JavaScript基础"></a>1、JavaScript基础</h2><h3 id="1-1、JavaScript概述-百度百科"><a href="#1-1、JavaScript概述-百度百科" class="headerlink" title="1.1、JavaScript概述(百度百科)"></a>1.1、JavaScript概述(百度百科)</h3><p><strong>概述：</strong></p><blockquote><p>JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。</p></blockquote><p><strong>历程：</strong></p><blockquote><p>JavaScript在1995年由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。</p></blockquote><p><strong>标准：</strong></p><blockquote><p>JavaScript的标准是ECMAScript 。截至 2012 年，所有浏览器都完整的支持ECMAScript 5.1，旧版本的浏览器至少支持ECMAScript 3 标准。2015年6月17日，ECMA国际组织发布了ECMAScript的第六版，该版本正式名称为 ECMAScript 2015，但通常被称为ECMAScript 6 或者ES2015。</p></blockquote><h3 id="1-2、JavaScript-的组成及其基本结构"><a href="#1-2、JavaScript-的组成及其基本结构" class="headerlink" title="1.2、JavaScript 的组成及其基本结构"></a>1.2、JavaScript 的组成及其基本结构</h3><h4 id="1-2-1、JavaScript-的组成"><a href="#1-2-1、JavaScript-的组成" class="headerlink" title="1.2.1、JavaScript 的组成"></a>1.2.1、JavaScript 的组成</h4><p><strong>JavaScript 由三部分组成：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/JavaScript%E7%BB%84%E6%88%90.png"></p><p><strong>1、ECMAScript：</strong></p><blockquote><p>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会，European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。</p></blockquote><p><strong>2、DOM：</strong></p><blockquote><p><strong>文档对象模型</strong>（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。它是一种与平台和语言无关的应用程序接口(API),它可以动态地访问程序和脚本,更新其内容、结构和www文档的风格(HTML和XML文档是通过说明部分定义的)。文档可以进一步被处理，处理的结果可以加入到当前的页面。DOM是一种基于树的API文档，它要求在处理过程中整个文档都表示在存储器中。另外一种简单的API是基于事件的SAX，它可以用于处理很大的XML文档，由于大，所以不适合全部放在存储器中处理。</p></blockquote><p><strong>3、BOM：</strong></p><blockquote><p>BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。</p></blockquote><p>ps:以上来源百度百科</p><h4 id="1-2-2、JavaScript-的基本结构"><a href="#1-2-2、JavaScript-的基本结构" class="headerlink" title="1.2.2、JavaScript 的基本结构"></a>1.2.2、JavaScript 的基本结构</h4><blockquote><p>在使用 JavaScript 时，可以用**<script>**标签将代码包裹后再嵌入 HTML 文档中。浏览器在遇到 **<script><strong>开始标签，将逐行读取代码，直到遇到</strong></script>**结束标签为止。</p></blockquote><p><strong>基本结构：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// JavaScript 语句;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>type：</strong></p><blockquote><p><strong>type</strong> 属性用于指定文本使用的语言类别是 <strong>text&#x2F;javascript</strong></p></blockquote><p><strong>注意：</strong></p><blockquote><ol><li>document.write() 表示用来向页面输出可以包含 HTML 标签的内容。</li><li>**<script></script>**可以包含在文档中的任何地方，需要保证这些代码在被使用前已读取并加载到内存。</li></ol></blockquote><h4 id="1-2-3、在网页中引入-JavaScript-代码"><a href="#1-2-3、在网页中引入-JavaScript-代码" class="headerlink" title="1.2.3、在网页中引入 JavaScript 代码"></a>1.2.3、在网页中引入 JavaScript 代码</h4><blockquote><p>将 <strong>JavaScript</strong> 代码引入网页中有三种方式，分别是<strong>内部 JavaScript</strong> 文件，<strong>外部 JavaScript 文件</strong> 及 <strong>行内 JavaScript</strong>（直接写在 HTML 标签中）</p></blockquote><p><strong>1、内部 JavaScript 文件：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript 的基本结构<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">writeln</span>(<span class="string">&quot;你好，JavaScript&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>2、外部 JavaScript 文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>外部 JavaScript 文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>index.js 文件代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">writeln</span>(<span class="string">&quot;你好，JavaScript&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>3、直接写在 HTML 标签中</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;直接写在 HTML 标签中&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot; value=&quot;单击弹出 对话框&quot; onclick=&quot;Javascript:alert(&#x27;你好，JavaScript&#x27;);&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>onclick：</strong>表示单击的事件处理程序，当用户单击按钮时，就会执行 <strong>Javascript:alert(‘你好，JavaScript’)</strong>;</p></blockquote><p><strong>应用场景：</strong></p><blockquote><ol><li>内部 JavaScript 文件仅适用于代码量较少的单个页面的情况。</li><li>外部 JavaScript 文件适用于代码量多，并且可以重复应用于多个页面的情况。</li><li>直接写在 HTML 标签中则适用于代码量极少的情况，但是这种方式增加了 HTML 代码，没有将结构与交互分离开，所以不推荐使用。</li></ol></blockquote><h3 id="1-3、JavaScript-的核心语法"><a href="#1-3、JavaScript-的核心语法" class="headerlink" title="1.3、JavaScript 的核心语法"></a>1.3、JavaScript 的核心语法</h3><blockquote><p><strong>JavaScript</strong> 的核心语法包含变量的声明和赋值、数据类型、运算符、逻辑控制语句等基本语法。</p></blockquote><p><strong>变量：</strong></p><blockquote><p><strong>变量</strong>是指程序中一个已经被命名的存储单元，它的主要作用是为数据操作提供存放信息的容器。<br><strong>JavaScript 声明变量时无须为其指定数据类型。</strong></p></blockquote><p><strong>1、变量的声明</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名; <span class="comment">// 使用 var 声明变量</span></span><br></pre></td></tr></table></figure><p>可以使用一个关键字 var 同时声明多个变量，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><ol><li>在 <strong>JavaScript</strong> 中，变量名区分英文字母大小写，所以字母大小写不同的变量名表示不同的变量。</li><li>变量可以不经过声明而被直接使用，但是这种方法很容易出错，且很难排错，不推荐使用。</li><li>变量命名规范：见命知意，还可以使用驼峰命名法：如 userName</li><li>变量命名不可以使用关键字命名，如 this，new，return…</li></ol></blockquote><p><strong>2、变量的赋值：</strong></p><blockquote><p><strong>var</strong> 变量名 &#x3D; 变量值；</p></blockquote><p>把右边的值使用 &#x3D; 赋给左边的变量</p><blockquote><p><strong>JavaScript</strong> 自动识别赋值的类型，所以无需定义变量类型</p></blockquote><h4 id="1-3-2、JavaScript-的数据类型"><a href="#1-3-2、JavaScript-的数据类型" class="headerlink" title="1.3.2、JavaScript 的数据类型"></a>1.3.2、JavaScript 的数据类型</h4><blockquote><p><strong>JavaScript</strong> 的弱类型脚本语言，声明变量时无须指定变量的数据类型，因为 JavaScript 变量的数据类型是解释时动态决定的。</p><p>在 <strong>JavaScript</strong> 中，提供了 <strong>3</strong> 种基本数据类型和 <strong>2</strong> 种特殊数据类型。</p></blockquote><p><strong>1. 基本数据类型：</strong></p><blockquote><p>基本数据类型包括数值类型（number）、字符串类型（string）及布尔类型（boolean）。</p></blockquote><p><strong>1）数值类型：</strong></p><blockquote><p>JavaScript 的数值类型不仅包括所有的整型变量，还包括所有的浮点型变量，如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">15.8</span>;</span><br></pre></td></tr></table></figure><blockquote><p>此外，JavaScript 支持八进制和十六进制。八进制以 0 开头，其后的数字可以任何八进制数字（0<del>7）；十六进制以 0x  或 0X 开头，其后的数字是任意的十六进制数字和字母（0</del>9 和 A ~ F）。如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">065</span>; <span class="comment">//065 等于十进制的 53</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">0X3f</span>;<span class="comment">//0X3f 等于十进制的 63</span></span><br></pre></td></tr></table></figure><blockquote><p>当数值类型超出了其表述范围时，将出现两个特殊值：Infinity（正无穷大）和 -Infinity（负无穷大）。</p></blockquote><blockquote><p>另外，在 JavaScript 中还有一个特殊值——NaN（Not a Number），表示非数字，它是数值类型。如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">typeof</span>(<span class="title class_">NaN</span>);<span class="comment">// 返回值为 number</span></span><br></pre></td></tr></table></figure><blockquote><p>以上的 typeof() 函数用于判断某个值或变量的数据类型。</p></blockquote><p><strong>2）字符串类型：</strong></p><blockquote><p>JavaScript 的字符串必须用引号括起来，此处的引号既可以是单引号，也可以是双引号。如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;123abc&quot;</span>；</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;123abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>字符串方法：</strong></p><blockquote><p>JavaScript 以 string 类表示字符串，string 类包含了一系列方法，如下：</p></blockquote><table><thead><tr><th>方法</th><th>用处</th></tr></thead><tbody><tr><td>charAt（）</td><td>返回指定位置的字符串。</td></tr><tr><td>toUpperCase（）</td><td>把字符串转换成大写。</td></tr><tr><td>toLowerCase（）</td><td>把字符串转换成小写。</td></tr><tr><td>indexOf（）</td><td>返回某个指定的字符串在字符串中首次出现的位置。</td></tr><tr><td>subString（）</td><td>用于提取字符串中介于两个指定下标之间的字符。（要前不要后）</td></tr><tr><td>split（）</td><td>用于把一个字符串分割成字符串数组。</td></tr><tr><td>replace（）</td><td>用于在字符串中用一些字符替换另一些字符。</td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">&quot;123abc456DEF&quot;</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;下标为 1 的字符是：&quot;</span>+str.<span class="title function_">charAt</span>(<span class="number">1</span>)+<span class="string">&#x27;&lt;br&gt;&#x27;</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;把字符串转换成大写：&quot;</span>+str.<span class="title function_">toUpperCase</span>()+<span class="string">&#x27;&lt;br&gt;&#x27;</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;把字符串转换成小写：&quot;</span>+str.<span class="title function_">toLowerCase</span>()+<span class="string">&#x27;&lt;br&gt;&#x27;</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;查找 abc 在 str 中首次出现的位置：&quot;</span>+str.<span class="title function_">indexOf</span>(<span class="string">&quot;abc&quot;</span>)+<span class="string">&#x27;&lt;br&gt;&#x27;</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;查找 xyz 在 str 中首次出现的位置：&quot;</span>+str.<span class="title function_">indexOf</span>(<span class="string">&quot;xyz&quot;</span>)+<span class="string">&#x27;&lt;br&gt;&#x27;</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;返回索引 6 和 9 之间的字符串：&quot;</span>+str.<span class="title function_">substring</span>(<span class="number">6</span>,<span class="number">9</span>)+<span class="string">&#x27;&lt;br&gt;&#x27;</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;把字符串 str 分割为字符串数组：&quot;</span>+str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)+<span class="string">&#x27;&lt;br&gt;&#x27;</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;把 DEF 替换成 789：&quot;</span>+str.<span class="title function_">replace</span>(<span class="string">&quot;DEF&quot;</span>,<span class="string">&quot;789&quot;</span>));</span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><p><strong>3）布尔类型：</strong></p><blockquote><p>布尔类型的值只有两个：<strong>true</strong> 和 <strong>false</strong>。布尔类型的值通常是逻辑运算的结果。</p></blockquote><p><strong>2.特殊数据类型：</strong></p><blockquote><p>特殊数据类型包括空类型（<strong>null</strong>）和未定义类型（<strong>undefined</strong>）。<br><strong>null</strong> 表示变量的值为空，可以用来检测某个变量是否被赋值<br><strong>undefined</strong> 类型的值只有一个 <strong>undefined</strong>，该值用于表示某个变量不存在，或者没有为其分配值，也用于表示对象的属性不存在。<br><strong>null与undefined</strong> </p></blockquote><blockquote><p>实际上，<strong>undefined</strong> 是 <strong>null</strong> 派生来的，如下为 <strong>true</strong>：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="literal">null</span> == <span class="literal">undefined</span>);  <span class="comment">// 返回值为 true</span></span><br></pre></td></tr></table></figure><blockquote><p>尽管这两个值相等，但是它们的含义不同，其区别在于 <strong>undefined</strong> 表示没有为变量设置值或属性不存在；<strong>null</strong> 表示变量是有值的，只是其值为 <strong>null</strong></p></blockquote><p><strong>3.判断数据类型：</strong></p><blockquote><p><strong>ECMAScript</strong> 提供了 <strong>typeof</strong> 运算符来判断某个值或变量的数据类型，其语法如下：</p></blockquote><p><strong>语法：</strong></p><blockquote><p><strong>typeof</strong>(值或变量);</p></blockquote><p><strong>返回值：</strong></p><blockquote><p>其返回值有如下几种：</p></blockquote><ul><li><strong>number</strong>：如果变量是数值类型，则返回 <strong>number</strong>。</li><li><strong>string</strong>：如果变量是字符串类型，则返回 <strong>string</strong>。</li><li><strong>boolean</strong>：如果变量是布尔类型，则返回 <strong>boolean</strong>。</li><li><strong>object</strong>：如果变量是空类型，或者是一种引用类型，如对象 、函数、数组、则返回 <strong>object</strong>。</li><li><strong>undefined</strong>：如果变量是未定义类型，则返回 <strong>undefined</strong>。</li></ul><h4 id="1-3-3、运算符"><a href="#1-3-3、运算符" class="headerlink" title="1.3.3、运算符"></a>1.3.3、运算符</h4><blockquote><p>在 JavaScript 中，运算符可分为算术运算符，比较运算符，逻辑运算符和赋值运算符，如下表：</p></blockquote><table><thead><tr><th align="center">运算符</th><th align="center">符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">算术运算符</td><td align="center">+</td><td align="center">加法</td></tr><tr><td align="center"></td><td align="center">-</td><td align="center">减法</td></tr><tr><td align="center"></td><td align="center">*</td><td align="center">乘法</td></tr><tr><td align="center"></td><td align="center">&#x2F;</td><td align="center">除法</td></tr><tr><td align="center"></td><td align="center">%</td><td align="center">取余</td></tr><tr><td align="center"></td><td align="center">++</td><td align="center">自增1</td></tr><tr><td align="center"></td><td align="center">- -</td><td align="center">自减1</td></tr><tr><td align="center">比较运算符</td><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center"></td><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center"></td><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center"></td><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center"></td><td align="center">&#x3D;&#x3D;</td><td align="center">是否等于</td></tr><tr><td align="center"></td><td align="center">!&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center"></td><td align="center">&#x3D;&#x3D;&#x3D;</td><td align="center">等值等型</td></tr><tr><td align="center"></td><td align="center">!&#x3D;&#x3D;</td><td align="center">不等值或不等型</td></tr><tr><td align="center">逻辑运算符</td><td align="center">&amp;&amp;</td><td align="center">逻辑与</td></tr><tr><td align="center"></td><td align="center">||</td><td align="center">逻辑或</td></tr><tr><td align="center"></td><td align="center">!</td><td align="center">逻辑非</td></tr><tr><td align="center">赋值运算符</td><td align="center">&#x3D;</td><td align="center">x&#x3D;y，等同于 x&#x3D;y</td></tr><tr><td align="center"></td><td align="center">+&#x3D;</td><td align="center">x+&#x3D;y，等同于 x&#x3D;x+y</td></tr><tr><td align="center"></td><td align="center">- &#x3D;</td><td align="center">x-&#x3D;y，等同于 x&#x3D;x-y</td></tr></tbody></table><p><strong>注意：</strong></p><blockquote><p>“<strong>&#x3D;&#x3D;</strong>“用于一般比较，在比较时会自动进行数据类型隐式转换;”<strong>&#x3D;&#x3D;&#x3D;</strong>“用于严格比较，即只要数据类型不匹配就返回 <strong>false</strong>。</p></blockquote><h4 id="1-3-4、逻辑控制语句"><a href="#1-3-4、逻辑控制语句" class="headerlink" title="1.3.4、逻辑控制语句"></a>1.3.4、逻辑控制语句</h4><blockquote><p>在 <strong>JavaScript</strong> 中，逻辑控制语句用于控制程序的执行顺序，其可以分为条件语句和循环语句。</p></blockquote><p><strong>1.条件语句：</strong></p><blockquote><p>条件语句可基于不同的条件执行不同的代码，其可以分为 <strong>if</strong> 语句和 <strong>switch</strong> 语句</p></blockquote><p><strong>1）if 语句：</strong></p><blockquote><p>在 <strong>if</strong> 语句中，可以有单分支语句，也可能有双分支语句，还可能有多分支语句。</p></blockquote><p><strong>（1）单分支语句：</strong></p><blockquote><p>由一个 <strong>if</strong> 组成，如果条件成立，则进入代码块开始执行语句，其语法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line"><span class="comment">// 条件为真（true）时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）双分支语句：</strong></p><blockquote><p>由两个分支线组成，如果 if 条件不成立，那么就会跳入 else 语句中，其语法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line"><span class="comment">// 条件为真（true）时执行的代码</span></span><br><span class="line">&#125;esle&#123;</span><br><span class="line"><span class="comment">// 条件为假（false）时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）多分支语句：</strong></p><blockquote><p>由多个 if…else 语句组合在一起，其语法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件)&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）switch 语句：</strong></p><blockquote><p>switch 语句比多分支语句结构更清晰，其语法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(条件)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line"><span class="keyword">default</span>：</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>以上语法中</strong>：<strong>break</strong> 关键字用于跳出某个 <strong>case</strong> 语句。如果不书写 <strong>break</strong> 语句，则进入 <strong>case</strong> 语句以后会继续进入后面的 <strong>case</strong> 语<strong>句</strong>；<strong>default</strong> 关键字用于书写默认的条件。如果前面的 <strong>case</strong> 语句都不满足，就进入 <strong>default</strong> 语句。</p></blockquote><p><strong>小结：</strong></p><blockquote><p><strong>JavaScript</strong> 中的 <strong>switch</strong> 语句和 <strong>if</strong> 语句都是用于条件判断的，但是当用于等值的多分支比较时，使用 <strong>switch</strong> 语句可以使程序的结构更加清晰。</p></blockquote><p><strong>2.循环语句：</strong></p><blockquote><p>在 <strong>JavaScript</strong> 中，循环语句分为 <strong>for</strong> 循环、<strong>while</strong> 循环、do-while 循环、<strong>for-in</strong> 循环，其中前三种循环语句与 <strong>Java</strong> 中的循环语句用法相同。</p></blockquote><p><strong>1）for 循环</strong></p><blockquote><p>基本语法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>；表达式<span class="number">2</span>；表达式<span class="number">3</span>)&#123;</span><br><span class="line">       <span class="comment">// 循环体</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>执行顺序：</strong></p><blockquote><p>首先执行<strong>表达式 1</strong> 初始化变量，然后进行<strong>表达式 2</strong> 循环条件的判断。如果<strong>表达式 2</strong> 成立，那么<strong>执行循环体</strong>。<strong>循环体执行结束</strong>后，<strong>表达式 3 增加&#x2F;减少初始化变量的值</strong>，然后再<strong>判断表达式 2 是否成立</strong>。如果成<strong>立就执行循环体</strong>；<strong>否则，循环结束</strong>。</p></blockquote><p><strong>2）while 循环</strong></p><blockquote><p>基本语法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件)&#123;</span><br><span class="line">       <span class="comment">// 循环体</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><blockquote><p>先判断后执行，当条件为真时，就执行循环体；当条件为假时，就退出循环。</p></blockquote><p><strong>3）do - while 循环</strong></p><blockquote><p>基本语法如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">// 循环体</span><br><span class="line">&#125;while(条件);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><blockquote><p>先执行后判断，该语句表示反复执行循环体，直到条件为假时才退出循环。</p></blockquote><p><strong>4）for-in 循环</strong></p><blockquote><p><strong>for - in</strong> 循环常用于对数组或对象的属性进行循环操作，基本语法如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(变量 in 对象)&#123;</span><br><span class="line">// 循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上语法中，“<strong>变量</strong>” 为指定的变量，可以是<strong>数组元素</strong>，也可以是<strong>对象的属性</strong>。</p></blockquote><h4 id="1-3-5、注释"><a href="#1-3-5、注释" class="headerlink" title="1.3.5、注释"></a>1.3.5、注释</h4><blockquote><p><strong>JavaScript</strong> 注释用于解释于标注 <strong>JavaScript</strong> 代码。</p></blockquote><p><strong>单行注释：</strong></p><blockquote><p>  &#x2F;&#x2F;</p></blockquote><p><strong>多行注释：</strong></p><blockquote><p>&#x2F;*      *&#x2F;</p></blockquote><blockquote><p>养成一个在开发中写注释的编程习惯很重要。</p></blockquote><h4 id="1-3-6、关键字和保留字"><a href="#1-3-6、关键字和保留字" class="headerlink" title="1.3.6、关键字和保留字"></a>1.3.6、关键字和保留字</h4><blockquote><p>一组具有特定用途的<strong>关键字</strong>，这些关键字可用于表示控制语句的<strong>开始</strong>或<strong>结束</strong>，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。</p></blockquote><blockquote><p>以下<strong>ECMAScript</strong>的全部关键字：</p></blockquote><p><strong>关键字：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/ECMAScript%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="ECMAScript关键字"></p><p><strong>保留字：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/ECMA%E4%BF%9D%E7%95%99%E5%AD%97.png" alt="ECMA保留字"></p><blockquote><p><strong>ps:以上图片来源于网络</strong></p></blockquote><h3 id="1-4、系统对话框"><a href="#1-4、系统对话框" class="headerlink" title="1.4、系统对话框"></a>1.4、系统对话框</h3><h4 id="1-4-1、alert（）"><a href="#1-4-1、alert（）" class="headerlink" title="1.4.1、alert（）"></a>1.4.1、alert（）</h4><blockquote><p><strong>alert()</strong> 方法用于向用户显示一个警告框，其中包含指定的文本和一个“<strong>确定</strong>”按钮。<br><strong>alert()</strong> 输出内容，可以是<strong>字符串或变量</strong>，与 <strong>document.write()相似</strong></p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/alert()%E5%AF%B9%E8%AF%9D%E6%A1%86.png" alt="image-20220509195205818"></p><blockquote><p><strong>alert（）方法没有返回值</strong></p></blockquote><h4 id="1-4-2、confirm（）"><a href="#1-4-2、confirm（）" class="headerlink" title="1.4.2、confirm（）"></a>1.4.2、confirm（）</h4><blockquote><p><strong>confirm()</strong> 方法用于向用户显示一个<strong>消息对话框</strong>，该对话框包含一个 ”确定“ 按钮和一个 ”取消按钮“。</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/confirm%E5%AF%B9%E8%AF%9D%E6%A1%86.png" alt="confirm对话框"></p><blockquote><p>其返回值是 true（确定）与 false（取消）</p></blockquote><h4 id="1-4-3、prompt（）"><a href="#1-4-3、prompt（）" class="headerlink" title="1.4.3、prompt（）"></a>1.4.3、prompt（）</h4><blockquote><p><strong>prompt（）</strong>方法会弹出一个<strong>提示对话框</strong>，等待用户输入一些数据。语法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">prompt</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="string">&quot;输入框的默认信息&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1010/image-20220509201121081.png" alt="image-20220509201121081"></p><blockquote><p>点击 确定 按钮返回文本框的值，点击 取消按钮 关闭对话框</p></blockquote><h3 id="1-5、总结"><a href="#1-5、总结" class="headerlink" title="1.5、总结"></a>1.5、总结</h3><p><strong>JavaScript的组成三部分：</strong></p><ul><li>ECMAScript</li><li>DOM</li><li>BOM</li></ul><p><strong>引入JavaScript的三种方式：</strong></p><ul><li>直接把 JavaScript 代码写在标签 &lt;script&gt; &lt;&#x2F;script&gt;之间；</li><li>使用外部 JavaScript 文件；</li><li>直接把简短的 JavaScript 代码写在 HTML 标签中</li></ul><p><strong>JavaScript 的基本数据类型：</strong></p><ul><li>数值类型（number）</li><li>字符串类型（string）</li><li>布尔类型（boolean）</li></ul><p><strong>JavaScript 的特殊数据类型：</strong></p><ul><li>空类型（null）</li><li>未定义类型（undefined）</li></ul><p><strong>JavaScript 的运算符：</strong></p><ul><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul><p><strong>JavaScript 的逻辑控制语句：</strong></p><ul><li>条件语句</li><li>循环语句</li></ul><p><strong>向用户显示信息：</strong></p><ul><li>alert() 警告对话框</li><li>confirm() 消息对话框</li><li>prompt() 提示对话框</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
